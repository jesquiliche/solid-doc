"use strict";(self.webpackChunksolid=self.webpackChunksolid||[]).push([[340],{3905:(e,a,r)=>{r.d(a,{Zo:()=>u,kt:()=>f});var i=r(7294);function o(e,a,r){return a in e?Object.defineProperty(e,a,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[a]=r,e}function n(e,a){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);a&&(i=i.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),r.push.apply(r,i)}return r}function t(e){for(var a=1;a<arguments.length;a++){var r=null!=arguments[a]?arguments[a]:{};a%2?n(Object(r),!0).forEach((function(a){o(e,a,r[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(r,a))}))}return e}function s(e,a){if(null==e)return{};var r,i,o=function(e,a){if(null==e)return{};var r,i,o={},n=Object.keys(e);for(i=0;i<n.length;i++)r=n[i],a.indexOf(r)>=0||(o[r]=e[r]);return o}(e,a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(i=0;i<n.length;i++)r=n[i],a.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=i.createContext({}),c=function(e){var a=i.useContext(l),r=a;return e&&(r="function"==typeof e?e(a):t(t({},a),e)),r},u=function(e){var a=c(e.components);return i.createElement(l.Provider,{value:a},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var a=e.children;return i.createElement(i.Fragment,{},a)}},m=i.forwardRef((function(e,a){var r=e.components,o=e.mdxType,n=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(r),m=o,f=d["".concat(l,".").concat(m)]||d[m]||p[m]||n;return r?i.createElement(f,t(t({ref:a},u),{},{components:r})):i.createElement(f,t({ref:a},u))}));function f(e,a){var r=arguments,o=a&&a.mdxType;if("string"==typeof e||o){var n=r.length,t=new Array(n);t[0]=m;var s={};for(var l in a)hasOwnProperty.call(a,l)&&(s[l]=a[l]);s.originalType=e,s[d]="string"==typeof e?e:o,t[1]=s;for(var c=2;c<n;c++)t[c]=r[c];return i.createElement.apply(null,t)}return i.createElement.apply(null,r)}m.displayName="MDXCreateElement"},7570:(e,a,r)=>{r.r(a),r.d(a,{assets:()=>l,contentTitle:()=>t,default:()=>p,frontMatter:()=>n,metadata:()=>s,toc:()=>c});var i=r(7462),o=(r(7294),r(3905));const n={sidebar_position:3},t="Principio de abierto/cerrado (OCP)",s={unversionedId:"tutorial-basics/OCP",id:"tutorial-basics/OCP",title:"Principio de abierto/cerrado (OCP)",description:"\xbfQu\xe9 es el principio OCP?",source:"@site/docs/tutorial-basics/03-OCP.md",sourceDirName:"tutorial-basics",slug:"/tutorial-basics/OCP",permalink:"/solid-doc/docs/tutorial-basics/OCP",draft:!1,editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/tutorial-basics/03-OCP.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Principio de responsabilidad \xfanica (SRP)",permalink:"/solid-doc/docs/tutorial-basics/SRP"},next:{title:"Principio de sustituci\xf3n de Liskov (LSP)",permalink:"/solid-doc/docs/tutorial-basics/LSP"}},l={},c=[{value:"\xbfQu\xe9 es el principio OCP?",id:"qu\xe9-es-el-principio-ocp",level:2},{value:"\xbfPor qu\xe9 es importante seguir el principio OCP?",id:"por-qu\xe9-es-importante-seguir-el-principio-ocp",level:2},{value:"Ejemplos de c\xf3mo aplicar el principio OCP en el desarrollo de software",id:"ejemplos-de-c\xf3mo-aplicar-el-principio-ocp-en-el-desarrollo-de-software",level:2},{value:"OCP y polimorfismo",id:"ocp-y-polimorfismo",level:3},{value:"OCP y Patrones de dise\xf1o",id:"ocp-y-patrones-de-dise\xf1o",level:3}],u={toc:c},d="wrapper";function p(e){let{components:a,...r}=e;return(0,o.kt)(d,(0,i.Z)({},u,r,{components:a,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"principio-de-abiertocerrado-ocp"},"Principio de abierto/cerrado (OCP)"),(0,o.kt)("h2",{id:"qu\xe9-es-el-principio-ocp"},"\xbfQu\xe9 es el principio OCP?"),(0,o.kt)("p",null,"El principio OCP (Open/Closed Principle) es un principio de dise\xf1o de software que establece que las entidades de software (clases, m\xf3dulos, funciones, etc.) deben estar abiertas para su extensi\xf3n pero cerradas para su modificaci\xf3n. En otras palabras, una entidad de software debe ser f\xe1cilmente extensible para agregar nuevas funcionalidades, pero no debe ser necesario modificar el c\xf3digo existente para hacerlo."),(0,o.kt)("p",null,"Este principio promueve la idea de que el software debe ser dise\xf1ado para permitir cambios y mejoras futuras, sin comprometer la estabilidad y funcionalidad existente. Al seguir este principio, se puede lograr un c\xf3digo m\xe1s modular, mantenible y escalable."),(0,o.kt)("p",null,'El principio OCP se considera uno de los principios SOLID, junto con SRP, LSP, ISP y DIP. Fue propuesto por el ingeniero de software Bertrand Meyer en su libro "Object-Oriented Software Construction" en 1988.'),(0,o.kt)("p",null,"El principio OCP (Open/Closed Principle, en ingl\xe9s) establece que las entidades de software (clases, m\xf3dulos, funciones, etc.) deben estar abiertas para la extensi\xf3n pero cerradas para la modificaci\xf3n. Esto significa que, cuando se agregan nuevas funcionalidades o se cambian los requisitos del sistema, se deben agregar nuevos elementos sin modificar los existentes."),(0,o.kt)("h2",{id:"por-qu\xe9-es-importante-seguir-el-principio-ocp"},"\xbfPor qu\xe9 es importante seguir el principio OCP?"),(0,o.kt)("p",null,"La importancia de seguir este principio radica en que permite lograr un dise\xf1o de software m\xe1s flexible, escalable y f\xe1cil de mantener. Al tener entidades que est\xe1n abiertas a la extensi\xf3n, se puede agregar nuevas funcionalidades sin tener que modificar el c\xf3digo existente, lo que reduce el riesgo de introducir errores en el sistema y aumenta la facilidad para mantenerlo en el futuro."),(0,o.kt)("p",null,"Adem\xe1s, el principio OCP promueve el uso de patrones de dise\xf1o como el patr\xf3n strategy o el patr\xf3n bridge, que permiten separar la implementaci\xf3n de una entidad de su uso y facilitan la creaci\xf3n de nuevas implementaciones sin modificar el c\xf3digo existente. En resumen, seguir el principio OCP permite lograr un dise\xf1o de software m\xe1s modular, flexible y f\xe1cil de mantener."),(0,o.kt)("admonition",{title:"Ejemplo sencillo",type:"tip"},(0,o.kt)("p",{parentName:"admonition"}," Imagina que tienes un software que permite a los usuarios crear y enviar correos electr\xf3nicos. Si en el futuro se quiere a\xf1adir la funcionalidad de enviar mensajes de texto tambi\xe9n, el principio OCP sugiere que no se debe modificar el c\xf3digo existente que maneja los correos electr\xf3nicos, sino que se debe agregar nuevo c\xf3digo que maneje los mensajes de texto, de modo que la modificaci\xf3n sea lo m\xe1s peque\xf1a y aislada posible. De esta manera, se mantiene el c\xf3digo existente sin alteraciones y se evitan errores no deseados en el futuro.")),(0,o.kt)("h2",{id:"ejemplos-de-c\xf3mo-aplicar-el-principio-ocp-en-el-desarrollo-de-software"},"Ejemplos de c\xf3mo aplicar el principio OCP en el desarrollo de software"),(0,o.kt)("p",null,"Supongamos que tenemos un programa que se encarga de calcular el \xe1rea de diferentes figuras geom\xe9tricas, como rect\xe1ngulos y c\xedrculos. Sin embargo, en el futuro es posible que se quieran a\xf1adir m\xe1s figuras, como tri\xe1ngulos o hex\xe1gonos."),(0,o.kt)("p",null,'En lugar de modificar la clase existente y a\xf1adir m\xe1s m\xe9todos para cada figura nueva, podemos crear una interfaz "Figura" y hacer que cada figura implemente esta interfaz con un m\xe9todo para calcular su \xe1rea. Luego, podemos crear una clase "CalculadoraAreas" que reciba objetos que implementen la interfaz "Figura" y calcule su \xe1rea sin importar su tipo.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-php"},"interface Figura {\n    public function calcularArea();\n}\n\nclass Rectangulo implements Figura {\n    private $base;\n    private $altura;\n    \n    public function __construct($base, $altura) {\n        $this->base = $base;\n        $this->altura = $altura;\n    }\n    \n    public function calcularArea() {\n        return $this->base * $this->altura;\n    }\n}\n\nclass Circulo implements Figura {\n    private $radio;\n    \n    public function __construct($radio) {\n        $this->radio = $radio;\n    }\n    \n    public function calcularArea() {\n        return pi() * pow($this->radio, 2);\n    }\n}\n\nclass CalculadoraAreas {\n    public function calcularAreaFigura(Figura $figura) {\n        return $figura->calcularArea();\n    }\n}\n\n// Uso\n$rectangulo = new Rectangulo(5, 10);\n$circulo = new Circulo(3);\n\n$calculadoraAreas = new CalculadoraAreas();\necho $calculadoraAreas->calcularAreaFigura($rectangulo); // Imprime 50\necho $calculadoraAreas->calcularAreaFigura($circulo); // Imprime 28.274333882308\n")),(0,o.kt)("p",null,'De esta manera, si en el futuro se desea a\xf1adir m\xe1s figuras geom\xe9tricas, solo habr\xeda que crear una clase que implemente la interfaz "Figura" y la calculadora de \xe1reas ya estar\xeda preparada para trabajar con ella sin necesidad de modificar su c\xf3digo.'),(0,o.kt)("h3",{id:"ocp-y-polimorfismo"},"OCP y polimorfismo"),(0,o.kt)("p",null,"El principio OCP se relaciona con el polimorfismo en el sentido de que el polimorfismo permite extender el comportamiento de una clase sin modificar su c\xf3digo fuente. De esta forma, se puede agregar nuevas funcionalidades o comportamientos a una clase sin afectar a su funcionamiento original, lo que respeta el principio OCP."),(0,o.kt)("p",null,"Por ejemplo, si se tiene una clase Figura con un m\xe9todo calcularArea() y se quiere agregar un nuevo tipo de figura como un c\xedrculo, se puede crear una nueva clase Circulo que extienda de Figura y sobrescriba el m\xe9todo calcularArea() para implementar la f\xf3rmula correspondiente al \xe1rea de un c\xedrculo. De esta forma, se cumple el principio OCP ya que se est\xe1 extendiendo el comportamiento de la clase Figura sin modificar su c\xf3digo fuente original."),(0,o.kt)("p",null,"En resumen, el polimorfismo permite agregar nuevas funcionalidades o comportamientos a una clase de forma extensible y sin modificar su c\xf3digo fuente original, lo que cumple con el principio OCP."),(0,o.kt)("admonition",{title:"Polimorfismo",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"El polimorfismo es un concepto de programaci\xf3n orientada a objetos que permite que un objeto pueda tomar varias formas o comportarse de diferentes maneras. Esto significa que un objeto puede ser utilizado como si fuera otro objeto relacionado, lo que permite una mayor flexibilidad en el dise\xf1o de software."),(0,o.kt)("p",{parentName:"admonition"},"El polimorfismo se puede lograr de varias maneras, como la sobrecarga de m\xe9todos, la sobrescritura de m\xe9todos, la implementaci\xf3n de interfaces y la herencia de clases. En general, el polimorfismo permite que los objetos se comporten de diferentes maneras seg\xfan el contexto en el que se utilizan, lo que facilita la modularidad y la reutilizaci\xf3n del c\xf3digo.")),(0,o.kt)("h3",{id:"ocp-y-patrones-de-dise\xf1o"},"OCP y Patrones de dise\xf1o"),(0,o.kt)("p",null,"Los patrones de dise\xf1o relacionados con OCP son principalmente el patr\xf3n Estrategia y el patr\xf3n Puente. Ambos patrones permiten separar la implementaci\xf3n de una clase de su uso, lo que facilita la extensi\xf3n del c\xf3digo sin modificarlo."))}p.isMDXComponent=!0}}]);