"use strict";(self.webpackChunksolid=self.webpackChunksolid||[]).push([[528],{3905:(e,a,t)=>{t.d(a,{Zo:()=>u,kt:()=>b});var r=t(7294);function n(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){n(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function s(e,a){if(null==e)return{};var t,r,n=function(e,a){if(null==e)return{};var t,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],a.indexOf(t)>=0||(n[t]=e[t]);return n}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var l=r.createContext({}),p=function(e){var a=r.useContext(l),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},u=function(e){var a=p(e.components);return r.createElement(l.Provider,{value:a},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},m=r.forwardRef((function(e,a){var t=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(t),m=n,b=d["".concat(l,".").concat(m)]||d[m]||c[m]||o;return t?r.createElement(b,i(i({ref:a},u),{},{components:t})):r.createElement(b,i({ref:a},u))}));function b(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var o=t.length,i=new Array(o);i[0]=m;var s={};for(var l in a)hasOwnProperty.call(a,l)&&(s[l]=a[l]);s.originalType=e,s[d]="string"==typeof e?e:n,i[1]=s;for(var p=2;p<o;p++)i[p]=t[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},6645:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var r=t(7462),n=(t(7294),t(3905));const o={sidebar_position:3},i="Patrones de dise\xf1o estructurales",s={unversionedId:"tutorial-extras/Estructurales",id:"tutorial-extras/Estructurales",title:"Patrones de dise\xf1o estructurales",description:"\xbfQu\xe9 son los patrones de dise\xf1o creacionales?",source:"@site/docs/tutorial-extras/03-Estructurales.md",sourceDirName:"tutorial-extras",slug:"/tutorial-extras/Estructurales",permalink:"/solid-doc/docs/tutorial-extras/Estructurales",draft:!1,editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/tutorial-extras/03-Estructurales.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Patrones de dise\xf1o creacionales",permalink:"/solid-doc/docs/tutorial-extras/Creacionales"}},l={},p=[{value:"\xbfQu\xe9 son los patrones de dise\xf1o creacionales?",id:"qu\xe9-son-los-patrones-de-dise\xf1o-creacionales",level:2},{value:"Tipos de patrones estructurales",id:"tipos-de-patrones-estructurales",level:2},{value:"Adapter",id:"adapter",level:3},{value:"Ejemplo de Adapter",id:"ejemplo-de-adapter",level:4},{value:"Desventajas de Adapter",id:"desventajas-de-adapter",level:4},{value:"Test de repaso",id:"test-de-repaso",level:4}],u={toc:p},d="wrapper";function c(e){let{components:a,...t}=e;return(0,n.kt)(d,(0,r.Z)({},u,t,{components:a,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"patrones-de-dise\xf1o-estructurales"},"Patrones de dise\xf1o estructurales"),(0,n.kt)("h2",{id:"qu\xe9-son-los-patrones-de-dise\xf1o-creacionales"},"\xbfQu\xe9 son los patrones de dise\xf1o creacionales?"),(0,n.kt)("p",null,"Los patrones de dise\xf1o estructurales son aquellos que se centran en c\xf3mo se organizan y estructuran las clases y objetos en un sistema. Estos patrones se utilizan para lograr una mayor flexibilidad y escalabilidad del sistema, al mismo tiempo que se reduce la complejidad y se mejora la eficiencia."),(0,n.kt)("p",null,"Los patrones estructurales incluyen patrones como el adaptador, el puente, el composite, el decorador, la fachada y el proxy. Cada uno de estos patrones se centra en un aspecto particular de la estructura del sistema y ofrece una soluci\xf3n com\xfan a un problema com\xfan que se encuentra en muchos sistemas."),(0,n.kt)("p",null,"Por ejemplo, el patr\xf3n adaptador se utiliza para permitir que dos clases incompatibles trabajen juntas. El patr\xf3n puente se utiliza para separar una abstracci\xf3n de su implementaci\xf3n, lo que permite que ambos cambien independientemente sin afectar al otro. El patr\xf3n composite se utiliza para tratar a un grupo de objetos como si fueran un solo objeto, lo que permite tratar a los objetos individuales y al grupo de objetos de la misma manera. El patr\xf3n decorador se utiliza para agregar funcionalidad a un objeto existente sin cambiar su estructura, mientras que el patr\xf3n fachada se utiliza para proporcionar una interfaz simple para un sistema complejo. Finalmente, el patr\xf3n proxy se utiliza para proporcionar un sustituto o marcador de posici\xf3n para otro objeto, lo que permite controlar el acceso al objeto real."),(0,n.kt)("h2",{id:"tipos-de-patrones-estructurales"},"Tipos de patrones estructurales"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Tipo de patr\xf3n estructural"),(0,n.kt)("th",{parentName:"tr",align:null},"Descripci\xf3n breve"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"Adapter"),(0,n.kt)("td",{parentName:"tr",align:null},"Convierte la interfaz de una clase en otra interfaz que se espera.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"Bridge"),(0,n.kt)("td",{parentName:"tr",align:null},"Separa una abstracci\xf3n de su implementaci\xf3n para que puedan variar independientemente.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"Composite"),(0,n.kt)("td",{parentName:"tr",align:null},"Agrupa objetos en una estructura de \xe1rbol para representar jerarqu\xedas parte-todo.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"Decorator"),(0,n.kt)("td",{parentName:"tr",align:null},"A\xf1ade responsabilidades adicionales a un objeto de manera din\xe1mica.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"Facade"),(0,n.kt)("td",{parentName:"tr",align:null},"Proporciona una interfaz unificada para un conjunto de interfaces en un subsistema.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"Flyweight"),(0,n.kt)("td",{parentName:"tr",align:null},"Divide los objetos en objetos compartidos y no compartidos para reducir la memoria utilizada.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"Proxy"),(0,n.kt)("td",{parentName:"tr",align:null},"Proporciona un representante o sustituto de otro objeto para controlar el acceso a \xe9ste.")))),(0,n.kt)("h3",{id:"adapter"},"Adapter"),(0,n.kt)("p",null,"El patr\xf3n ",(0,n.kt)("strong",{parentName:"p"},"Adapter")," es un patr\xf3n estructural que permite que objetos con interfaces incompatibles trabajen juntos. Convierte la interfaz de una clase en otra interfaz que el cliente espera."),(0,n.kt)("p",null,"El patr\xf3n ",(0,n.kt)("strong",{parentName:"p"},"Adapter")," se puede clasificar en dos tipos: el Adapter de clase y el Adapter de objeto. El Adapter de clase utiliza la herencia para adaptar una interfaz existente, mientras que el Adapter de objeto utiliza la composici\xf3n para adaptar una interfaz existente."),(0,n.kt)("p",null,"El objetivo del patr\xf3n Adapter es proporcionar una capa intermedia entre dos interfaces incompatibles para permitir su interacci\xf3n. Esto se logra mediante la creaci\xf3n de un objeto adaptador que convierte la interfaz original en la interfaz esperada por el cliente."),(0,n.kt)("p",null,"Ejemplos de este patr\xf3n se pueden encontrar en el uso de adaptadores de enchufe, donde se utilizan para permitir que dispositivos con diferentes enchufes se conecten a una toma de corriente com\xfan. Tambi\xe9n se puede utilizar en el software, por ejemplo, para convertir los datos de una fuente de datos en un formato que pueda ser utilizado por una aplicaci\xf3n."),(0,n.kt)("p",null,"En este ejemplo, la interfaz ",(0,n.kt)("strong",{parentName:"p"},"Product")," define la operaci\xf3n que todos los productos deben implementar. ConcreteProduct1 y ConcreteProduct2 son implementaciones concretas de ",(0,n.kt)("strong",{parentName:"p"},"Product"),". La clase abstracta ",(0,n.kt)("strong",{parentName:"p"},"Creator")," define el m\xe9todo factoryMethod que las subclases deben implementar para crear los objetos. ",(0,n.kt)("strong",{parentName:"p"},"ConcreteCreator1")," y ",(0,n.kt)("strong",{parentName:"p"},"ConcreteCreator2")," son las implementaciones concretas de Creator que devuelven instancias concretas de ",(0,n.kt)("strong",{parentName:"p"},"ConcreteProduct1")," y ",(0,n.kt)("strong",{parentName:"p"},"ConcreteProduct2"),", respectivamente. La funci\xf3n clientCode demuestra c\xf3mo se pueden utilizar las clases anteriores para crear diferentes tipos de objetos."),(0,n.kt)("h4",{id:"ejemplo-de-adapter"},"Ejemplo de Adapter"),(0,n.kt)("p",null,"Supongamos que tenemos una clase PaymentProcessor que procesa pagos utilizando la API de un proveedor de pagos espec\xedfico. Pero ahora queremos cambiar a un nuevo proveedor de pagos que tiene una API diferente. En lugar de cambiar la l\xf3gica de PaymentProcessor, podemos crear un adaptador para la nueva API y utilizarlo para procesar pagos. Este adaptador actuar\xe1 como un intermediario entre el PaymentProcessor y la nueva API."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-js"},'interface PaymentProvider {\n    public function pay($amount);\n}\n\nclass OldPaymentProvider implements PaymentProvider {\n    public function pay($amount) {\n        echo "Pagando $amount usando la API de OldPaymentProvider\\n";\n    }\n}\n\nclass NewPaymentProvider {\n    public function charge($amount) {\n        echo "Cobrando $amount usando la API de NewPaymentProvider\\n";\n    }\n}\n\nclass NewPaymentProviderAdapter implements PaymentProvider {\n    private $provider;\n\n    public function __construct(NewPaymentProvider $provider) {\n        $this->provider = $provider;\n    }\n\n    public function pay($amount) {\n        $this->provider->charge($amount);\n    }\n}\n\nclass PaymentProcessor {\n    private $provider;\n\n    public function __construct(PaymentProvider $provider) {\n        $this->provider = $provider;\n    }\n\n    public function processPayment($amount) {\n        $this->provider->pay($amount);\n    }\n}\n\n// Usando el viejo proveedor de pagos\n$paymentProcessor = new PaymentProcessor(new OldPaymentProvider());\n$paymentProcessor->processPayment(100);\n\n// Cambiando al nuevo proveedor de pagos con un adaptador\n$newPaymentProvider = new NewPaymentProvider();\n$paymentProcessor = new PaymentProcessor(new NewPaymentProviderAdapter($newPaymentProvider));\n$paymentProcessor->processPayment(200);\n\n')),(0,n.kt)("p",null,"En este ejemplo, ",(0,n.kt)("strong",{parentName:"p"},"OldPaymentProvider")," y ",(0,n.kt)("strong",{parentName:"p"},"NewPaymentProvider")," son dos proveedores de pagos diferentes con APIs diferentes. ",(0,n.kt)("strong",{parentName:"p"},"PaymentProcessor")," es la clase que utiliza la API del proveedor de pagos para procesar pagos. En lugar de cambiar la implementaci\xf3n de ",(0,n.kt)("strong",{parentName:"p"},"PaymentProcessor")," cuando cambiamos al nuevo proveedor de pagos, creamos un adaptador ",(0,n.kt)("strong",{parentName:"p"},"NewPaymentProviderAdapter")," que se encarga de adaptar la API del nuevo proveedor de pagos a la interfaz del PaymentProvider. De esta manera, podemos seguir utilizando la misma implementaci\xf3n de PaymentProcessor sin necesidad de cambiar nada en \xe9l."),(0,n.kt)("h4",{id:"desventajas-de-adapter"},"Desventajas de Adapter"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Complejidad: La implementaci\xf3n del patr\xf3n Adapter puede ser compleja, ya que implica la creaci\xf3n de una interfaz com\xfan para hacer que los objetos sean compatibles entre s\xed.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Overhead: El patr\xf3n Adapter agrega una capa adicional de indirecci\xf3n, lo que puede aumentar el overhead y disminuir el rendimiento.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Aumento de la complejidad del c\xf3digo: El uso excesivo de adaptadores puede aumentar la complejidad del c\xf3digo y hacerlo m\xe1s dif\xedcil de mantener y entender.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Requiere una buena planificaci\xf3n: Es importante planificar cuidadosamente c\xf3mo se va a implementar el patr\xf3n Adapter para evitar problemas en el futuro.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Dificultad para mantener la compatibilidad: A medida que evolucionan los sistemas, puede ser dif\xedcil mantener la compatibilidad entre los diferentes objetos que se est\xe1n adaptando."))),(0,n.kt)("h4",{id:"test-de-repaso"},"Test de repaso"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},(0,n.kt)("em",{parentName:"strong"},"\xbfCu\xe1l es el prop\xf3sito del patr\xf3n Adapter?")))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"a) Permitir que los objetos trabajen juntos sin modificar su interfaz."),(0,n.kt)("li",{parentName:"ul"},"b) Permitir que los objetos trabajen juntos modificando su interfaz."),(0,n.kt)("li",{parentName:"ul"},"c) Permitir que los objetos trabajen individualmente sin interferir en la interfaz de otros objetos."),(0,n.kt)("li",{parentName:"ul"},"Respuesta: a) Permitir que los objetos trabajen juntos sin modificar su interfaz.")),(0,n.kt)("ol",{start:2},(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},(0,n.kt)("em",{parentName:"strong"},"\xbfCu\xe1les son las dos formas principales de implementar el patr\xf3n Adapter?")))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"a) Clases y objetos."),(0,n.kt)("li",{parentName:"ul"},"b) Herencia y composici\xf3n."),(0,n.kt)("li",{parentName:"ul"},"c) Interfaces y clases abstractas."),(0,n.kt)("li",{parentName:"ul"},"Respuesta: b) Herencia y composici\xf3n.")),(0,n.kt)("ol",{start:3},(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},(0,n.kt)("em",{parentName:"strong"},'\xbfQu\xe9 es un "Adapter de objeto"?')))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"a) Una clase que adapta una interfaz de objeto existente a otra interfaz requerida por el cliente."),(0,n.kt)("li",{parentName:"ul"},"b) Un objeto que se utiliza para conectar una aplicaci\xf3n con una base de datos."),(0,n.kt)("li",{parentName:"ul"},"c) Una interfaz que define una serie de m\xe9todos para que los objetos los implementen."),(0,n.kt)("li",{parentName:"ul"},"Respuesta: a) Una clase que adapta una interfaz de objeto existente a otra interfaz requerida por el cliente.")),(0,n.kt)("ol",{start:4},(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},(0,n.kt)("em",{parentName:"strong"},"\xbfEn qu\xe9 se diferencia el patr\xf3n Adapter del patr\xf3n Bridge?")))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"a) El patr\xf3n Adapter se utiliza para adaptar una interfaz existente, mientras que el patr\xf3n Bridge se utiliza para separar la interfaz de una abstracci\xf3n de su implementaci\xf3n."),(0,n.kt)("li",{parentName:"ul"},"b) El patr\xf3n Adapter se utiliza para conectar dos interfaces incompatibles, mientras que el patr\xf3n Bridge se utiliza para conectar dos sistemas diferentes."),(0,n.kt)("li",{parentName:"ul"},"c) El patr\xf3n Adapter se utiliza en sistemas distribuidos, mientras que el patr\xf3n Bridge se utiliza en sistemas centralizados."),(0,n.kt)("li",{parentName:"ul"},"Respuesta: a) El patr\xf3n Adapter se utiliza para adaptar una interfaz existente, mientras que el patr\xf3n Bridge se utiliza para separar la interfaz de una abstracci\xf3n de su implementaci\xf3n.")),(0,n.kt)("ol",{start:5},(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("strong",{parentName:"li"},(0,n.kt)("em",{parentName:"strong"},"\xbfEn qu\xe9 situaciones es \xfatil utilizar el patr\xf3n Adapter?")))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"a) Cuando se necesita adaptar una interfaz existente a una nueva interfaz requerida por el cliente."),(0,n.kt)("li",{parentName:"ul"},"b) Cuando se necesita crear una interfaz abstracta para separar una abstracci\xf3n de su implementaci\xf3n."),(0,n.kt)("li",{parentName:"ul"},"c) Cuando se necesita controlar el acceso a un objeto y su comportamiento."),(0,n.kt)("li",{parentName:"ul"},"Respuesta: a) Cuando se necesita adaptar una interfaz existente a una nueva interfaz requerida por el cliente.")))}c.isMDXComponent=!0}}]);