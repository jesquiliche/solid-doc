"use strict";(self.webpackChunksolid=self.webpackChunksolid||[]).push([[990],{3905:(e,a,t)=>{t.d(a,{Zo:()=>u,kt:()=>b});var n=t(7294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function l(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function s(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=n.createContext({}),c=function(e){var a=n.useContext(i),t=a;return e&&(t="function"==typeof e?e(a):l(l({},a),e)),t},u=function(e){var a=c(e.components);return n.createElement(i.Provider,{value:a},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},m=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(t),m=r,b=p["".concat(i,".").concat(m)]||p[m]||d[m]||o;return t?n.createElement(b,l(l({ref:a},u),{},{components:t})):n.createElement(b,l({ref:a},u))}));function b(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var o=t.length,l=new Array(o);l[0]=m;var s={};for(var i in a)hasOwnProperty.call(a,i)&&(s[i]=a[i]);s.originalType=e,s[p]="string"==typeof e?e:r,l[1]=s;for(var c=2;c<o;c++)l[c]=t[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,t)}m.displayName="MDXCreateElement"},4341:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>i,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=t(7462),r=(t(7294),t(3905));const o={sidebar_position:2},l="Patrones de dise\xf1o creacionales",s={unversionedId:"tutorial-extras/Creacionales",id:"tutorial-extras/Creacionales",title:"Patrones de dise\xf1o creacionales",description:"\xbfQu\xe9 son los patrones de dise\xf1o creacionales?",source:"@site/docs/tutorial-extras/02-Creacionales.mdx",sourceDirName:"tutorial-extras",slug:"/tutorial-extras/Creacionales",permalink:"/solid-doc/docs/tutorial-extras/Creacionales",draft:!1,editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/tutorial-extras/02-Creacionales.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Patrones de dise\xf1o",permalink:"/solid-doc/docs/category/patrones-de-dise\xf1o"},next:{title:"Patrones de dise\xf1o estructurales",permalink:"/solid-doc/docs/tutorial-extras/Estructurales"}},i={},c=[{value:"\xbfQu\xe9 son los patrones de dise\xf1o creacionales?",id:"qu\xe9-son-los-patrones-de-dise\xf1o-creacionales",level:2},{value:"Tipos de patrones creacionales",id:"tipos-de-patrones-creacionales",level:2},{value:"Factory Method",id:"factory-method",level:3},{value:"Ejemplo de Factory Method",id:"ejemplo-de-factory-method",level:4},{value:"Desventajas de Factory Method",id:"desventajas-de-factory-method",level:4},{value:"Test de repaso",id:"test-de-repaso",level:4},{value:"Respuestas",id:"respuestas",level:4},{value:"Abstract Factory",id:"abstract-factory",level:3},{value:"Ejemplo de Abstract Factory",id:"ejemplo-de-abstract-factory",level:4},{value:"Desventajas de Abstract Factory",id:"desventajas-de-abstract-factory",level:4},{value:"Test",id:"test",level:4},{value:"Respuestas",id:"respuestas-1",level:4},{value:"Builder",id:"builder",level:3},{value:"Ejemplo de Builder",id:"ejemplo-de-builder",level:4},{value:"Desventajas de Builder",id:"desventajas-de-builder",level:4},{value:"Test",id:"test-1",level:4},{value:"Prototype",id:"prototype",level:3},{value:"Ejemplo de desarrollo Prototype",id:"ejemplo-de-desarrollo-prototype",level:4},{value:"Desventajas de Prototype",id:"desventajas-de-prototype",level:4},{value:"Test",id:"test-2",level:4},{value:"Singleton",id:"singleton",level:3},{value:"Ejemplo de desarrollo Singleton",id:"ejemplo-de-desarrollo-singleton",level:4},{value:"Desventajas de Singleton",id:"desventajas-de-singleton",level:4},{value:"Test de conocimientos generales",id:"test-de-conocimientos-generales",level:3}],u={toc:c},p="wrapper";function d(e){let{components:a,...t}=e;return(0,r.kt)(p,(0,n.Z)({},u,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"patrones-de-dise\xf1o-creacionales"},"Patrones de dise\xf1o creacionales"),(0,r.kt)("h2",{id:"qu\xe9-son-los-patrones-de-dise\xf1o-creacionales"},"\xbfQu\xe9 son los patrones de dise\xf1o creacionales?"),(0,r.kt)("p",null,"Los patrones de dise\xf1o creacionales son un conjunto de patrones de dise\xf1o de software que se utilizan para abstraer el proceso de creaci\xf3n de objetos y permitir que el c\xf3digo sea m\xe1s flexible, escalable y f\xe1cil de mantener. Estos patrones se centran en la creaci\xf3n de objetos de manera eficiente y en la gesti\xf3n de las dependencias entre objetos para minimizar el acoplamiento y aumentar la cohesi\xf3n en el c\xf3digo. Los patrones creacionales se utilizan para resolver problemas relacionados con la creaci\xf3n de objetos, como la creaci\xf3n de objetos en tiempo de ejecuci\xf3n, la gesti\xf3n de la creaci\xf3n de objetos y la creaci\xf3n de objetos complejos."),(0,r.kt)("h2",{id:"tipos-de-patrones-creacionales"},"Tipos de patrones creacionales"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Patr\xf3n de dise\xf1o"),(0,r.kt)("th",{parentName:"tr",align:null},"Descripci\xf3n"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Factory Method")),(0,r.kt)("td",{parentName:"tr",align:null},"Define una interfaz para crear objetos en una superclase, pero permite que las subclases alteren el tipo de objetos que se crear\xe1n.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Abstract Factory")),(0,r.kt)("td",{parentName:"tr",align:null},"Proporciona una interfaz para crear familias de objetos relacionados o dependientes sin especificar sus clases concretas.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Builder")),(0,r.kt)("td",{parentName:"tr",align:null},"Separa la construcci\xf3n de un objeto complejo de su representaci\xf3n, de modo que el mismo proceso de construcci\xf3n pueda crear diferentes representaciones.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Prototype")),(0,r.kt)("td",{parentName:"tr",align:null},"Especifica los tipos de objetos a crear utilizando una instancia protot\xedpica y crea nuevos objetos copiando este prototipo.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Singleton")),(0,r.kt)("td",{parentName:"tr",align:null},"Garantiza que una clase tenga solo una instancia y proporciona un punto de acceso global a ella.")))),(0,r.kt)("h3",{id:"factory-method"},"Factory Method"),(0,r.kt)("p",null,"El patr\xf3n ",(0,r.kt)("strong",{parentName:"p"},"Factory Method")," es un patr\xf3n creacional que proporciona una interfaz para crear objetos en una superclase, pero permite a las subclases alterar el tipo de objetos que se crear\xe1n. En otras palabras, el patr\xf3n Factory Method proporciona una forma de encapsular la creaci\xf3n de objetos en una jerarqu\xeda de clases."),(0,r.kt)("p",null,"El patr\xf3n ",(0,r.kt)("strong",{parentName:"p"},"Factory Method")," se compone de los siguientes componentes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Product:")," la interfaz para los objetos que se crear\xe1n.\nlas implementaciones concretas de Product."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Creator:")," la clase abstracta que define el m\xe9todo de f\xe1brica que crea los objetos."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"ConcreteCreator:")," las implementaciones concretas de Creator que devuelven una instancia concreta de ConcreteProduct.\nEl siguiente es un ejemplo de implementaci\xf3n del patr\xf3n Factory Method en PHP:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'<?php\ninterface Product {\n    public function operation(): string;\n}\n\nclass ConcreteProduct1 implements Product {\n    public function operation(): string {\n        return "ConcreteProduct1";\n    }\n}\n\nclass ConcreteProduct2 implements Product {\n    public function operation(): string {\n        return "ConcreteProduct2";\n    }\n}\n\nabstract class Creator {\n    abstract public function factoryMethod(): Product;\n\n    public function someOperation(): string {\n        $product = $this->factoryMethod();\n        $result = "Creator: The same creator\'s code has just worked with " . $product->operation();\n\n        return $result;\n    }\n}\n\nclass ConcreteCreator1 extends Creator {\n    public function factoryMethod(): Product {\n        return new ConcreteProduct1();\n    }\n}\n\nclass ConcreteCreator2 extends Creator {\n    public function factoryMethod(): Product {\n        return new ConcreteProduct2();\n    }\n}\n\nfunction clientCode(Creator $creator) {\n    echo "Client: I\'m not aware of the creator\'s class, but it still works.\\n"\n        . $creator->someOperation();\n}\n\necho "App: Launched with the ConcreteCreator1.\\n";\nclientCode(new ConcreteCreator1());\necho "\\n\\n";\n\necho "App: Launched with the ConcreteCreator2.\\n";\nclientCode(new ConcreteCreator2());\n')),(0,r.kt)("p",null,"En este ejemplo, la interfaz ",(0,r.kt)("strong",{parentName:"p"},"Product")," define la operaci\xf3n que todos los productos deben implementar. ConcreteProduct1 y ConcreteProduct2 son implementaciones concretas de ",(0,r.kt)("strong",{parentName:"p"},"Product"),". La clase abstracta ",(0,r.kt)("strong",{parentName:"p"},"Creator")," define el m\xe9todo factoryMethod que las subclases deben implementar para crear los objetos. ",(0,r.kt)("strong",{parentName:"p"},"ConcreteCreator1")," y ",(0,r.kt)("strong",{parentName:"p"},"ConcreteCreator2")," son las implementaciones concretas de Creator que devuelven instancias concretas de ",(0,r.kt)("strong",{parentName:"p"},"ConcreteProduct1")," y ",(0,r.kt)("strong",{parentName:"p"},"ConcreteProduct2"),", respectivamente. La funci\xf3n clientCode demuestra c\xf3mo se pueden utilizar las clases anteriores para crear diferentes tipos de objetos."),(0,r.kt)("h4",{id:"ejemplo-de-factory-method"},"Ejemplo de Factory Method"),(0,r.kt)("p",null,"El ejemplo proporcionado es un ejemplo de Factory Method en PHP utilizando la librer\xeda PDO para conectarse a una base de datos MySQL, Oracle y SQL Server. En este ejemplo, se crea una clase abstracta DBConnector que contiene un m\xe9todo abstracto connect(). Luego, se crean clases concretas que extienden DBConnector para cada tipo de base de datos que se desea soportar: MySQLConnector, OracleConnector y SQLServerConnector. Cada clase concreta proporciona una implementaci\xf3n espec\xedfica del m\xe9todo connect() que se utiliza para establecer la conexi\xf3n con la base de datos correspondiente."),(0,r.kt)("p",null,"Para utilizar el Factory Method, se crea una clase DBConnectionFactory que tiene un m\xe9todo est\xe1tico getDBConnection($dbType) que devuelve una instancia de la clase DBConnector correspondiente al tipo de base de datos especificado. Dentro de este m\xe9todo, se utiliza una estructura condicional para determinar qu\xe9 clase concreta debe ser instanciada en funci\xf3n del tipo de base de datos especificado."),(0,r.kt)("p",null,"Finalmente, se utiliza el m\xe9todo getDBConnection() de DBConnectionFactory para obtener una instancia de la clase concreta adecuada y, a continuaci\xf3n, se llama al m\xe9todo connect() de esa instancia para establecer la conexi\xf3n con la base de datos correspondiente."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"<?php\n\nabstract class Connection {\n    protected $dsn;\n    protected $username;\n    protected $password;\n\n    abstract public function connect(): PDO;\n}\n\nclass MySqlConnection extends Connection {\n    public function __construct(string $host, string $port, string $dbname, string $username, string $password) {\n        $this->dsn = \"mysql:host=$host;port=$port;dbname=$dbname\";\n        $this->username = $username;\n        $this->password = $password;\n    }\n\n    public function connect(): PDO {\n        return new PDO($this->dsn, $this->username, $this->password);\n    }\n}\n\nclass OracleConnection extends Connection {\n    public function __construct(string $host, string $port, string $dbname, string $username, string $password) {\n        $this->dsn = \"oci:host=$host;port=$port;dbname=$dbname\";\n        $this->username = $username;\n        $this->password = $password;\n    }\n\n    public function connect(): PDO {\n        return new PDO($this->dsn, $this->username, $this->password);\n    }\n}\n\nclass SqlServerConnection extends Connection {\n    public function __construct(string $host, string $port, string $dbname, string $username, string $password) {\n        $this->dsn = \"sqlsrv:Server=$host,$port;Database=$dbname\";\n        $this->username = $username;\n        $this->password = $password;\n    }\n\n    public function connect(): PDO {\n        return new PDO($this->dsn, $this->username, $this->password);\n    }\n}\n\n$mysqlConn = new MySqlConnection('localhost', '3306', 'mydatabase', 'myuser', 'mypassword');\n$mysql = $mysqlConn->connect();\n\n$oracleConn = new OracleConnection('localhost', '1521', 'oracledb', 'myuser', 'mypassword');\n$oracle = $oracleConn->connect();\n\n$sqlServerConn = new SqlServerConnection('localhost', '1433', 'sqlserverdb', 'myuser', 'mypassword');\n$sqlServer = $sqlServerConn->connect();\n")),(0,r.kt)("h4",{id:"desventajas-de-factory-method"},"Desventajas de Factory Method"),(0,r.kt)("p",null,"El patr\xf3n Factory Method presenta algunas desventajas, entre ellas se pueden mencionar:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Complejidad: Puede aumentar la complejidad del c\xf3digo ya que introduce nuevas clases y abstracciones."),(0,r.kt)("li",{parentName:"ul"},"Dificultad para manejar dependencias: Cuando se utilizan clases concretas en lugar de interfaces, puede ser dif\xedcil manejar las dependencias de las diferentes implementaciones."),(0,r.kt)("li",{parentName:"ul"},"C\xf3digo redundante: En algunos casos, puede haber una cantidad significativa de c\xf3digo redundante en las subclases del Factory Method si tienen un comportamiento similar."),(0,r.kt)("li",{parentName:"ul"},"Posibles problemas de rendimiento: Si el Factory Method se utiliza en exceso, puede haber problemas de rendimiento debido a la creaci\xf3n de muchas instancias de objetos.\nSin embargo, estas desventajas no siempre se aplican y pueden ser mitigadas con un dise\xf1o adecuado y el uso de patrones complementarios. Adem\xe1s, el patr\xf3n Factory Method proporciona una forma flexible y escalable de crear objetos y puede ser muy \xfatil en muchas situaciones.")),(0,r.kt)("p",null,"Ejemplos de c\xf3mo aplicar el principio DIP en el desarrollo de software"),(0,r.kt)("h4",{id:"test-de-repaso"},"Test de repaso"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l es el objetivo principal del patr\xf3n Factory Method?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Proporcionar una interfaz para crear objetos en una superclase, pero permitiendo a las subclases alterar el tipo de objeto que se crea."),(0,r.kt)("li",{parentName:"ul"},"b) Proporcionar una interfaz para acceder a un grupo de objetos relacionados."),(0,r.kt)("li",{parentName:"ul"},"c) Proporcionar una manera de crear objetos de diferentes tipos sin especificar expl\xedcitamente las clases de los objetos.")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1les son los roles principales en el patr\xf3n Factory Method?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Producto, Creador, Cliente."),(0,r.kt)("li",{parentName:"ul"},"b) Producto, Factory, Cliente."),(0,r.kt)("li",{parentName:"ul"},"c) Creador, Factory, Cliente.")),(0,r.kt)("p",null,"3.",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"}," \xbfCu\xe1l es la ventaja principal del patr\xf3n Factory Method?"))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Ayuda a encapsular el proceso de creaci\xf3n de objetos."),(0,r.kt)("li",{parentName:"ul"},"b) Ayuda a optimizar el rendimiento de la aplicaci\xf3n."),(0,r.kt)("li",{parentName:"ul"},"c) Ayuda a reducir la complejidad de la aplicaci\xf3n.")),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l es la diferencia entre el patr\xf3n Factory Method y el patr\xf3n Abstract Factory?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) El patr\xf3n Factory Method define una interfaz para crear un objeto, mientras que el patr\xf3n Abstract Factory define una interfaz para crear una familia de objetos relacionados."),(0,r.kt)("li",{parentName:"ul"},"b) El patr\xf3n Factory Method solo se usa en situaciones donde la creaci\xf3n de objetos es compleja, mientras que el patr\xf3n Abstract Factory se usa en cualquier situaci\xf3n de creaci\xf3n de objetos."),(0,r.kt)("li",{parentName:"ul"},"c) El patr\xf3n Factory Method solo se usa con clases abstractas, mientras que el patr\xf3n Abstract Factory se usa con clases concretas.\nRespuesta: a)")),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l es la desventaja principal del patr\xf3n Factory Method?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Puede aumentar la complejidad del c\xf3digo al requerir la creaci\xf3n de m\xfaltiples clases."),(0,r.kt)("li",{parentName:"ul"},"b) Puede aumentar la complejidad del c\xf3digo al requerir la creaci\xf3n de una sola clase."),(0,r.kt)("li",{parentName:"ul"},"c) Puede disminuir la flexibilidad de la aplicaci\xf3n al limitar las opciones de creaci\xf3n de objetos.")),(0,r.kt)("h4",{id:"respuestas"},"Respuestas"),(0,r.kt)("p",null,"\xbfQu\xe9 es el patr\xf3n Factory Method?"),(0,r.kt)("p",null,"Respuesta correcta: El patr\xf3n de dise\xf1o Factory Method define una interfaz para crear objetos, pero deja que las subclases decidan qu\xe9 clase instanciar.\n\xbfCu\xe1l es la ventaja principal del patr\xf3n Factory Method?"),(0,r.kt)("p",null,"Respuesta correcta: La ventaja principal del patr\xf3n Factory Method es que permite el encapsulamiento de la creaci\xf3n de objetos y la flexibilidad para cambiar la clase concreta de un objeto sin cambiar el c\xf3digo que lo usa.\n\xbfC\xf3mo se implementa el patr\xf3n Factory Method?"),(0,r.kt)("p",null,"Respuesta correcta: El patr\xf3n Factory Method se implementa definiendo una interfaz para crear objetos en una clase abstracta, y luego definiendo una o m\xe1s subclases que implementan esta interfaz para crear objetos de diferentes tipos.\n\xbfQu\xe9 es una f\xe1brica concreta?"),(0,r.kt)("p",null,"Respuesta correcta: Una f\xe1brica concreta es una subclase que implementa la interfaz de la f\xe1brica abstracta para crear objetos de un tipo espec\xedfico.\n\xbfEn qu\xe9 se diferencia el patr\xf3n Factory Method del patr\xf3n Abstract Factory?"),(0,r.kt)("p",null,"Respuesta correcta: El patr\xf3n Factory Method define una interfaz para crear un solo objeto, mientras que el patr\xf3n Abstract Factory define una interfaz para crear familias de objetos relacionados entre s\xed."),(0,r.kt)("h3",{id:"abstract-factory"},"Abstract Factory"),(0,r.kt)("p",null,"El patr\xf3n Abstract Factory es \xfatil cuando se requiere crear familias de objetos relacionados o dependientes entre s\xed, sin tener que especificar expl\xedcitamente sus clases concretas."),(0,r.kt)("p",null,"Este patr\xf3n es especialmente \xfatil en situaciones donde un sistema debe ser independiente de c\xf3mo se crean, compuestas o representan sus objetos."),(0,r.kt)("p",null,"Adem\xe1s, el uso de Abstract Factory tambi\xe9n permite que el c\xf3digo sea m\xe1s escalable y flexible en el futuro, ya que se puede agregar f\xe1cilmente nuevas familias de objetos sin tener que cambiar el c\xf3digo existente."),(0,r.kt)("p",null,"En resumen, Abstract Factory sirve para crear objetos relacionados o dependientes entre s\xed, manteniendo la independencia de c\xf3mo se crean y mejorando la escalabilidad y flexibilidad del c\xf3digo."),(0,r.kt)("h4",{id:"ejemplo-de-abstract-factory"},"Ejemplo de Abstract Factory"),(0,r.kt)("p",null,"Supongamos que queremos implementar una tienda en l\xednea que vende productos electr\xf3nicos y queremos utilizar el patr\xf3n Abstract Factory para manejar las diferentes categor\xedas de productos que ofrecemos."),(0,r.kt)("p",null,"Primero, definimos la interfaz para la f\xe1brica abstracta que nos permitir\xe1 crear los diferentes tipos de productos electr\xf3nicos:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"interface ElectronicFactory {\n    public function createLaptop(): Laptop;\n    public function createSmartphone(): Smartphone;\n}\n")),(0,r.kt)("p",null,"Luego, implementamos la f\xe1brica concreta para la categor\xeda de productos Apple:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class AppleFactory implements ElectronicFactory {\n    public function createLaptop(): Laptop {\n        return new MacBook();\n    }\n    \n    public function createSmartphone(): Smartphone {\n        return new iPhone();\n    }\n}\n")),(0,r.kt)("p",null,"La f\xe1brica concreta para la categor\xeda de productos Samsung:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class SamsungFactory implements ElectronicFactory {\n    public function createLaptop(): Laptop {\n        return new Notebook();\n    }\n    \n    public function createSmartphone(): Smartphone {\n        return new Galaxy();\n    }\n}\n")),(0,r.kt)("p",null,"A continuaci\xf3n, definimos la interfaz para cada tipo de producto electr\xf3nico que queremos crear:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"interface Laptop {\n    public function getDescription(): string;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"interface Smartphone {\n    public function getDescription(): string;\n}\n")),(0,r.kt)("p",null,"Implementamos cada tipo de producto en cada categor\xeda:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'class MacBook implements Laptop {\n    public function getDescription(): string {\n        return "This is a MacBook.";\n    }\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'class iPhone implements Smartphone {\n    public function getDescription(): string {\n        return "This is an iPhone.";\n    }\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'class Notebook implements Laptop {\n    public function getDescription(): string {\n        return "This is a Samsung notebook.";\n    }\n}\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'class Galaxy implements Smartphone {\n    public function getDescription(): string {\n        return "This is a Samsung Galaxy.";\n    }\n}\n')),(0,r.kt)("p",null,"Finalmente, creamos un cliente que utilice el patr\xf3n Abstract Factory para crear los productos electr\xf3nicos que necesitamos:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'class Client {\n    private $laptop;\n    private $smartphone;\n    \n    public function __construct(ElectronicFactory $factory) {\n        $this->laptop = $factory->createLaptop();\n        $this->smartphone = $factory->createSmartphone();\n    }\n    \n    public function showProducts() {\n        echo $this->laptop->getDescription() . "\\n";\n        echo $this->smartphone->getDescription() . "\\n";\n    }\n}\n')),(0,r.kt)("p",null,"Y podemos crear objetos de la siguiente manera:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"$appleFactory = new AppleFactory();\n$client1 = new Client($appleFactory);\n$client1->showProducts();\n\n$samsungFactory = new SamsungFactory();\n$client2 = new Client($samsungFactory);\n$client2->showProducts();\n")),(0,r.kt)("h4",{id:"desventajas-de-abstract-factory"},"Desventajas de Abstract Factory"),(0,r.kt)("p",null,"Algunas de las desventajas de Abstract Factory son:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Complejidad: Abstract Factory puede aumentar la complejidad de un c\xf3digo, especialmente si se utilizan muchas jerarqu\xedas de f\xe1brica y clases de productos.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Rigidez: Si se necesita agregar una nueva variante de producto, tambi\xe9n se debe agregar una nueva jerarqu\xeda de f\xe1brica correspondiente. Esto puede llevar a una rigidez en el dise\xf1o y una mayor complejidad.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Escalabilidad: A medida que el n\xfamero de productos y variantes aumenta, el n\xfamero de clases de f\xe1brica y productos puede crecer exponencialmente, lo que dificulta la escalabilidad del dise\xf1o.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Sobrecarga: El uso de Abstract Factory puede aumentar la sobrecarga del procesamiento, ya que cada instancia de f\xe1brica requiere una instancia de cada producto que puede crear.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Dificultad en la implementaci\xf3n: La implementaci\xf3n de Abstract Factory puede requerir m\xe1s tiempo y esfuerzo en comparaci\xf3n con otros patrones de dise\xf1o creacionales m\xe1s simples, como el patr\xf3n Factory Method."))),(0,r.kt)("h4",{id:"test"},"Test"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfQu\xe9 patr\xf3n de dise\xf1o est\xe1 relacionado con la creaci\xf3n de objetos?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A. Abstract Factory"),(0,r.kt)("li",{parentName:"ul"},"B. Adapter"),(0,r.kt)("li",{parentName:"ul"},"C. Bridge"),(0,r.kt)("li",{parentName:"ul"},"D. Composite")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l es el objetivo principal de Abstract Factory?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A. Proporcionar una interfaz para crear objetos de una familia de productos relacionados sin especificar su clase concreta."),(0,r.kt)("li",{parentName:"ul"},"B. Convertir la interfaz de una clase en otra interfaz que los clientes esperan."),(0,r.kt)("li",{parentName:"ul"},"C. Separar la abstracci\xf3n de su implementaci\xf3n para que ambas puedan variar de forma independiente."),(0,r.kt)("li",{parentName:"ul"},"D. Proporcionar una manera de acceder a un objeto en particular sin exponer su estructura interna.")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l de las siguientes opciones es una caracter\xedstica de Abstract Factory?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A. El cliente interact\xfaa directamente con los productos que crea la f\xe1brica."),(0,r.kt)("li",{parentName:"ul"},"B. La f\xe1brica abstracta define la interfaz para la creaci\xf3n de objetos de una familia de productos relacionados."),(0,r.kt)("li",{parentName:"ul"},"C. La f\xe1brica concreta crea objetos de una sola familia de productos."),(0,r.kt)("li",{parentName:"ul"},"D. El patr\xf3n requiere la creaci\xf3n de una clase abstracta adicional para representar la f\xe1brica concreta.")),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},'\xbfQu\xe9 es una "familia de productos" en el contexto de Abstract Factory?')))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A. Un grupo de objetos que tienen una relaci\xf3n de herencia entre s\xed."),(0,r.kt)("li",{parentName:"ul"},"B. Un conjunto de objetos relacionados que tienen una funci\xf3n o prop\xf3sito com\xfan."),(0,r.kt)("li",{parentName:"ul"},"C. Un grupo de objetos que se crean juntos a partir de una misma f\xe1brica."),(0,r.kt)("li",{parentName:"ul"},"D. Un conjunto de objetos que comparten la misma interfaz.")),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l es una desventaja potencial de Abstract Factory?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A. Puede ser dif\xedcil de implementar correctamente."),(0,r.kt)("li",{parentName:"ul"},"B. Requiere la creaci\xf3n de m\xfaltiples clases abstractas y concretas."),(0,r.kt)("li",{parentName:"ul"},"C. No proporciona una manera f\xe1cil de extender la creaci\xf3n de nuevos productos."),(0,r.kt)("li",{parentName:"ul"},"D. Puede introducir una complejidad innecesaria en el dise\xf1o.")),(0,r.kt)("h4",{id:"respuestas-1"},"Respuestas"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfQu\xe9 es Abstract Factory?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Respuesta correcta: b) Un patr\xf3n de dise\xf1o creacional que proporciona una interfaz para crear familias de objetos relacionados sin especificar sus clases concretas.")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l es el objetivo principal de Abstract Factory?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Respuesta correcta: c) Proporcionar una interfaz para crear familias de objetos relacionados o dependientes sin especificar sus clases concretas.")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l es la diferencia entre Factory Method y Abstract Factory?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Respuesta correcta: a) Factory Method define una interfaz para crear un solo objeto, mientras que Abstract Factory define una interfaz para crear familias de objetos relacionados.")),(0,r.kt)("p",null,"$. ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"\xbfQu\xe9 ventaja proporciona Abstract Factory en comparaci\xf3n con Factory Method?"))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Respuesta correcta: d) Abstract Factory proporciona una mayor flexibilidad y capacidad de extensi\xf3n que Factory Method, ya que permite la creaci\xf3n de familias de objetos relacionados en lugar de objetos individuales.")),(0,r.kt)("p",null,"\xbfCu\xe1l es una desventaja potencial de Abstract Factory?"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Respuesta correcta: b) Puede resultar complicado de implementar si las familias de objetos son muy complejas o si cambian con frecuencia. Adem\xe1s, puede requerir la creaci\xf3n de m\xfaltiples clases para cada familia de objetos.")),(0,r.kt)("h3",{id:"builder"},"Builder"),(0,r.kt)("p",null,"El patr\xf3n de dise\xf1o Builder se utiliza para separar la construcci\xf3n de un objeto complejo de su representaci\xf3n, permitiendo que el mismo proceso de construcci\xf3n pueda crear diferentes representaciones. Es \xfatil cuando se desea crear objetos compuestos, es decir, objetos que est\xe1n compuestos de varias partes, pero donde estas partes no necesariamente deben ser usadas juntas."),(0,r.kt)("p",null,"El patr\xf3n Builder se compone de una clase abstracta Builder, que define los m\xe9todos necesarios para construir cada parte del objeto complejo, y de una clase Director, que dirige el proceso de construcci\xf3n utilizando el Builder. Tambi\xe9n hay una clase ConcreteBuilder para cada representaci\xf3n del objeto complejo, que implementa los m\xe9todos de Builder y construye la representaci\xf3n espec\xedfica del objeto."),(0,r.kt)("p",null,"Un ejemplo pr\xe1ctico de Builder es la construcci\xf3n de un objeto Pizza. En este ejemplo, la clase abstracta Builder define los m\xe9todos para construir la masa, los ingredientes y la cobertura de la pizza, mientras que la clase ConcreteBuilder construye una pizza concreta (como una pizza de pepperoni) y la clase Director utiliza el Builder para construir una pizza completa."),(0,r.kt)("p",null,"Una de las principales ventajas del patr\xf3n Builder es que permite la creaci\xf3n de objetos complejos de manera incremental, lo que hace que el proceso de construcci\xf3n sea m\xe1s flexible y f\xe1cil de controlar. Adem\xe1s, permite que el proceso de construcci\xf3n sea independiente de la representaci\xf3n final del objeto, lo que facilita la creaci\xf3n de m\xfaltiples representaciones."),(0,r.kt)("p",null,"Entre las desventajas del patr\xf3n Builder se encuentra que puede ser un patr\xf3n complejo y dif\xedcil de implementar, especialmente para objetos muy complejos. Adem\xe1s, puede resultar en una sobrecarga de clases, lo que puede dificultar la comprensi\xf3n del c\xf3digo."),(0,r.kt)("p",null,"En resumen, el patr\xf3n Builder es una herramienta \xfatil para la construcci\xf3n de objetos complejos y flexibles, que permite la creaci\xf3n de m\xfaltiples representaciones del mismo objeto. Si bien puede ser dif\xedcil de implementar, puede facilitar el control del proceso de construcci\xf3n y mejorar la flexibilidad del c\xf3digo."),(0,r.kt)("h4",{id:"ejemplo-de-builder"},"Ejemplo de Builder"),(0,r.kt)("p",null,"En este ejemplo, la clase Burger representa el producto final, que en este caso es una hamburguesa. La clase BurgerBuilder es el constructor que crea diferentes tipos de hamburguesas. El cliente utiliza la clase BurgerBuilder para crear una hamburguesa, a\xf1adiendo los ingredientes que desee mediante llamadas a los m\xe9todos addCheese(), addPepperoni(), addLettuce(), addTomato() y finalmente llama al m\xe9todo build() para construir el objeto Burger final."),(0,r.kt)("p",null,"Una ventaja de este enfoque es que permite al cliente construir objetos complejos sin tener que preocuparse por el proceso de construcci\xf3n. Adem\xe1s, como la clase BurgerBuilder es responsable de la construcci\xf3n de objetos, el c\xf3digo es m\xe1s f\xe1cil de mantener y modificar en el futuro."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'<?php\n// Product\nclass Burger {\n  private $size;\n  private $cheese = false;\n  private $pepperoni = false;\n  private $lettuce = false;\n  private $tomato = false;\n\n  public function __construct(BurgerBuilder $builder) {\n    $this->size = $builder->size;\n    $this->cheese = $builder->cheese;\n    $this->pepperoni = $builder->pepperoni;\n    $this->lettuce = $builder->lettuce;\n    $this->tomato = $builder->tomato;\n  }\n\n  public function describe() {\n    $description = "This is a {$this->size} burger";\n    if ($this->cheese) {\n      $description .= " with cheese";\n    }\n    if ($this->pepperoni) {\n      $description .= " with pepperoni";\n    }\n    if ($this->lettuce) {\n      $description .= " with lettuce";\n    }\n    if ($this->tomato) {\n      $description .= " with tomato";\n    }\n    return $description;\n  }\n}\n\n// Builder\nclass BurgerBuilder {\n  public $size;\n  public $cheese = false;\n  public $pepperoni = false;\n  public $lettuce = false;\n  public $tomato = false;\n\n  public function __construct($size) {\n    $this->size = $size;\n  }\n\n  public function addCheese() {\n    $this->cheese = true;\n    return $this;\n  }\n\n  public function addPepperoni() {\n    $this->pepperoni = true;\n    return $this;\n  }\n\n  public function addLettuce() {\n    $this->lettuce = true;\n    return $this;\n  }\n\n  public function addTomato() {\n    $this->tomato = true;\n    return $this;\n  }\n\n  public function build() {\n    return new Burger($this);\n  }\n}\n\n// Client\n$builder = new BurgerBuilder("large");\n$burger = $builder->addCheese()->addPepperoni()->addLettuce()->build();\necho $burger->describe(); // This is a large burger with cheese with pepperoni with lettuce\n')),(0,r.kt)("h4",{id:"desventajas-de-builder"},"Desventajas de Builder"),(0,r.kt)("p",null,"Algunas desventajas del patr\xf3n Builder pueden incluir:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Aumenta la complejidad del c\xf3digo: El patr\xf3n Builder puede aumentar la complejidad del c\xf3digo ya que requiere la creaci\xf3n de m\xfaltiples clases y objetos.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Requiere m\xe1s recursos de memoria: El proceso de construcci\xf3n de objetos puede requerir una cantidad significativa de recursos de memoria, lo que puede ser un problema en aplicaciones que tienen limitaciones de memoria.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"No se adapta bien a objetos simples: El patr\xf3n Builder es m\xe1s \xfatil para la construcci\xf3n de objetos complejos, por lo que no es la mejor opci\xf3n para objetos simples que se pueden construir f\xe1cilmente con un constructor b\xe1sico.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Puede introducir errores: El proceso de construcci\xf3n de objetos utilizando el patr\xf3n Builder es m\xe1s complejo que la creaci\xf3n de objetos utilizando un constructor b\xe1sico, lo que aumenta la posibilidad de errores.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Puede ser dif\xedcil de entender para los desarrolladores nuevos: Los desarrolladores nuevos pueden encontrar el patr\xf3n Builder dif\xedcil de entender y puede tomarles tiempo aprender c\xf3mo funciona y c\xf3mo implementarlo correctamente en su c\xf3digo."))),(0,r.kt)("h4",{id:"test-1"},"Test"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l es el prop\xf3sito del patr\xf3n de dise\xf1o Builder?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Simplificar la creaci\xf3n de objetos complejos."),(0,r.kt)("li",{parentName:"ul"},"b) Permitir la creaci\xf3n de objetos sin necesidad de una clase constructora."),(0,r.kt)("li",{parentName:"ul"},"c) Facilitar la modificaci\xf3n de la estructura de un objeto."),(0,r.kt)("li",{parentName:"ul"},"Respuesta: a) Simplificar la creaci\xf3n de objetos complejos.")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfQu\xe9 problema resuelve el patr\xf3n de dise\xf1o Builder?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Crear objetos complejos de forma sencilla y flexible."),(0,r.kt)("li",{parentName:"ul"},"b) Crear objetos sin necesidad de una clase constructora."),(0,r.kt)("li",{parentName:"ul"},"c) Crear objetos que no se puedan modificar una vez construidos."),(0,r.kt)("li",{parentName:"ul"},"Respuesta: a) Crear objetos complejos de forma sencilla y flexible.")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l es la diferencia entre el patr\xf3n de dise\xf1o Builder y el patr\xf3n de dise\xf1o Factory Method?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) El patr\xf3n Builder simplifica la creaci\xf3n de objetos complejos mientras que el patr\xf3n Factory Method se encarga de crear objetos sin especificar su clase concreta."),(0,r.kt)("li",{parentName:"ul"},"b) El patr\xf3n Factory Method se encarga de crear objetos complejos mientras que el patr\xf3n Builder se encarga de crear objetos sin especificar su clase concreta."),(0,r.kt)("li",{parentName:"ul"},"c) El patr\xf3n Builder y el patr\xf3n Factory Method resuelven el mismo problema."),(0,r.kt)("li",{parentName:"ul"},"Respuesta: a) El patr\xf3n Builder simplifica la creaci\xf3n de objetos complejos mientras que el patr\xf3n Factory Method se encarga de crear objetos sin especificar su clase concreta.")),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfC\xf3mo se compone el patr\xf3n de dise\xf1o Builder?")),"-")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Director, Builder y Producto."),(0,r.kt)("li",{parentName:"ul"},"b) Constructor, Productor y Director."),(0,r.kt)("li",{parentName:"ul"},"c) Constructor, Director y Producto."),(0,r.kt)("li",{parentName:"ul"},"Respuesta: a) Director, Builder y Producto.")),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1ndo se debe usar el patr\xf3n de dise\xf1o Builder?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Cuando se necesite crear objetos complejos de forma sencilla y flexible."),(0,r.kt)("li",{parentName:"ul"},"b) Cuando se necesite crear objetos sin especificar su clase concreta."),(0,r.kt)("li",{parentName:"ul"},"c) Cuando se necesite crear objetos que no se puedan modificar una vez construidos."),(0,r.kt)("li",{parentName:"ul"},"Respuesta: a) Cuando se necesite crear objetos complejos de forma sencilla y flexible.")),(0,r.kt)("h3",{id:"prototype"},"Prototype"),(0,r.kt)("p",null,'El patr\xf3n de dise\xf1o Prototype es un patr\xf3n creacional que permite la creaci\xf3n de nuevos objetos a partir de la clonaci\xf3n de objetos existentes. En lugar de crear nuevos objetos utilizando la palabra clave "new", este patr\xf3n crea nuevos objetos copiando uno existente. Esto es \xfatil cuando la creaci\xf3n de objetos es costosa en t\xe9rminos de tiempo y recursos.'),(0,r.kt)("p",null,'El patr\xf3n Prototype se basa en la implementaci\xf3n de un m\xe9todo "clone()" que copia los atributos de un objeto existente a un nuevo objeto. El objeto original se conoce como "prototipo" y se utiliza como base para la creaci\xf3n de nuevos objetos.'),(0,r.kt)("p",null,"Este patr\xf3n puede ser utilizado cuando:"),(0,r.kt)("p",null,"La creaci\xf3n de objetos es costosa en t\xe9rminos de tiempo y recursos.\nEl n\xfamero de clases a instanciar es limitado y se conocen de antemano.\nLos objetos a crear son variantes de un objeto existente.\nUna de las ventajas de este patr\xf3n es que puede reducir el acoplamiento entre las clases y aumentar la flexibilidad del c\xf3digo."),(0,r.kt)("p",null,"Sin embargo, una de las desventajas es que el patr\xf3n puede ser m\xe1s dif\xedcil de implementar en lenguajes que no tienen soporte integrado para la clonaci\xf3n de objetos, y puede ser m\xe1s dif\xedcil de entender y mantener si no se utiliza de manera adecuada."),(0,r.kt)("p",null,"En resumen, el patr\xf3n Prototype permite la creaci\xf3n de nuevos objetos a partir de la clonaci\xf3n de objetos existentes, lo que puede ser \xfatil cuando la creaci\xf3n de objetos es costosa en t\xe9rminos de tiempo y recursos. Aunque puede aumentar la flexibilidad y reducir el acoplamiento entre clases, puede ser m\xe1s dif\xedcil de implementar y entender si no se utiliza de manera adecuada."),(0,r.kt)("p",null,"\xbfEn qu\xe9 se basa el patr\xf3n Prototype?"),(0,r.kt)("p",null,'El patr\xf3n Prototype se basa en la implementaci\xf3n de un m\xe9todo "clone()" que copia los atributos de un objeto existente a un nuevo objeto. El objeto original se conoce como "prototipo" y se utiliza como base para la creaci\xf3n de nuevos objetos.'),(0,r.kt)("p",null,"\xbfPara qu\xe9 se utiliza el patr\xf3n Prototype?"),(0,r.kt)("p",null,"El patr\xf3n Prototype se utiliza para crear nuevos objetos a partir de la clonaci\xf3n de objetos existentes. Esto puede ser \xfatil cuando la creaci\xf3n de objetos es costosa en t\xe9rminos de tiempo y recursos, y cuando los objetos a crear son variantes de un objeto existente."),(0,r.kt)("p",null,"\xbfQu\xe9 es un prototipo en el patr\xf3n Prototype?"),(0,r.kt)("p",null,"Un prototipo en el patr\xf3n Prototype es un objeto existente que se utiliza como base para la creaci\xf3n de nuevos objetos. El prototipo se clona para crear un nuevo objeto con los mismos atributos."),(0,r.kt)("p",null,"\xbfCu\xe1l es una de las ventajas del patr\xf3n Prototype?"),(0,r.kt)("p",null,"Una de las ventajas del patr\xf3n Prototype es que puede reducir el acoplamiento entre las clases y aumentar la flexibilidad del c\xf3digo."),(0,r.kt)("p",null,"\xbfCu\xe1l es una de las desventajas del patr\xf3n Prototype?"),(0,r.kt)("p",null,"Una de las desventajas del patr\xf3n Prototype es que puede ser m\xe1s dif\xedcil de implementar en lenguajes que no tienen soporte integrado para la clonaci\xf3n de objetos, y puede ser m\xe1s dif\xedcil de entender y mantener si no se utiliza de manera adecuada."),(0,r.kt)("h4",{id:"ejemplo-de-desarrollo-prototype"},"Ejemplo de desarrollo Prototype"),(0,r.kt)("p",null,"En este ejemplo, creamos un objeto prototipo Car con un color rojo, modelo BMW y 2 puertas. Luego, clonamos este objeto prototipo para crear un nuevo objeto Car con color azul y 4 puertas. Finalmente, mostramos la informaci\xf3n del nuevo objeto Car creado a partir del prototipo."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Clase base Vehicle\nclass Vehicle\n{\n    private $color;\n    private $numRuedas;\n    private $modelo;\n\n    public function __construct($color, $numRuedas, $modelo)\n    {\n        $this->color = $color;\n        $this->numRuedas = $numRuedas;\n        $this->modelo = $modelo;\n    }\n\n    // Getter y setters para las propiedades privadas\n    public function getColor()\n    {\n        return $this->color;\n    }\n\n    public function setColor($color)\n    {\n        $this->color = $color;\n    }\n\n    public function getNumRuedas()\n    {\n        return $this->numRuedas;\n    }\n\n    public function setNumRuedas($numRuedas)\n    {\n        $this->numRuedas = $numRuedas;\n    }\n\n    public function getModelo()\n    {\n        return $this->modelo;\n    }\n\n    public function setModelo($modelo)\n    {\n        $this->modelo = $modelo;\n    }\n\n    // M\xe9todo clone para crear un nuevo objeto a partir del prototipo\n    public function __clone()\n    {\n        return new Vehicle($this->color, $this->numRuedas, $this->modelo);\n    }\n}\n\n// Subclase Car\nclass Car extends Vehicle\n{\n    private $numPuertas;\n\n    public function __construct($color, $modelo, $numPuertas)\n    {\n        parent::__construct($color, 4, $modelo);\n        $this->numPuertas = $numPuertas;\n    }\n\n    // Getter y setter para la propiedad privada\n    public function getNumPuertas()\n    {\n        return $this->numPuertas;\n    }\n\n    public function setNumPuertas($numPuertas)\n    {\n        $this->numPuertas = $numPuertas;\n    }\n}\n\n// Creamos un objeto prototipo\n$carProto = new Car(\'Rojo\', \'BMW\', 2);\n\n// Clonamos el prototipo para crear un nuevo objeto Car\n$newCar = clone $carProto;\n$newCar->setColor(\'Azul\');\n$newCar->setNumPuertas(4);\n\n// Mostramos la informaci\xf3n del nuevo objeto Car\necho "Color: " . $newCar->getColor() . "<br>";\necho "Modelo: " . $newCar->getModelo() . "<br>";\necho "N\xfamero de puertas: " . $newCar->getNumPuertas() . "<br>";\necho "N\xfamero de ruedas: " . $newCar->getNumRuedas() . "<br>";\n')),(0,r.kt)("h4",{id:"desventajas-de-prototype"},"Desventajas de Prototype"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Clonaci\xf3n profunda: Aunque la clonaci\xf3n de un objeto es una tarea f\xe1cil y efectiva en muchos casos, puede ser compleja cuando el objeto a clonar tiene referencias a otros objetos. En este caso, se requerir\xe1 una clonaci\xf3n profunda, que puede ser dif\xedcil y propensa a errores.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Costo de memoria: La clonaci\xf3n de objetos puede ser costosa en t\xe9rminos de memoria, especialmente si se clonan objetos grandes y complejos con frecuencia. Esto puede afectar el rendimiento de la aplicaci\xf3n en t\xe9rminos de tiempo de ejecuci\xf3n y uso de memoria.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Inestabilidad: Si un objeto prototipo cambia despu\xe9s de ser clonado, puede haber efectos secundarios no deseados en todos los objetos clonados. Esto puede llevar a un comportamiento inesperado de la aplicaci\xf3n y puede ser dif\xedcil de depurar.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Uso limitado: El patr\xf3n Prototype se adapta mejor a situaciones donde los objetos son complejos y costosos de crear. Si los objetos son simples y se pueden crear f\xe1cilmente, el patr\xf3n Prototype puede agregar una complejidad innecesaria a la aplicaci\xf3n.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Dise\xf1o inicial complejo: La implementaci\xf3n del patr\xf3n Prototype puede requerir una estructura de clase compleja para manejar la clonaci\xf3n de objetos. Esto puede hacer que el dise\xf1o inicial de la aplicaci\xf3n sea m\xe1s complicado y dif\xedcil de entender."))),(0,r.kt)("h4",{id:"test-2"},"Test"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l es el objetivo principal del patr\xf3n Prototype?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Simplificar la creaci\xf3n de objetos complejos."),(0,r.kt)("li",{parentName:"ul"},"b) Permitir la creaci\xf3n de objetos con diferentes implementaciones."),(0,r.kt)("li",{parentName:"ul"},"c) Permitir la creaci\xf3n de nuevos objetos clonando objetos existentes."),(0,r.kt)("li",{parentName:"ul"},"Respuesta: c)")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfQu\xe9 m\xe9todo se utiliza para clonar objetos en PHP?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) __clone()"),(0,r.kt)("li",{parentName:"ul"},"b) __construct()"),(0,r.kt)("li",{parentName:"ul"},"c) __create()"),(0,r.kt)("li",{parentName:"ul"},"Respuesta: a)")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},'\xbfQu\xe9 significa la frase "shallow copy" en relaci\xf3n con la clonaci\xf3n de objetos?')))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Que se copian solo las propiedades de nivel superior del objeto."),(0,r.kt)("li",{parentName:"ul"},"b) Que se copian todas las propiedades y m\xe9todos del objeto."),(0,r.kt)("li",{parentName:"ul"},"c) Que se crea una copia exacta del objeto original."),(0,r.kt)("li",{parentName:"ul"},"Respuesta: a)")),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l es la diferencia entre el patr\xf3n Prototype y el patr\xf3n Singleton?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) El patr\xf3n Singleton se utiliza para crear una \xfanica instancia de una clase, mientras que el patr\xf3n Prototype se utiliza para crear m\xfaltiples instancias de una clase."),(0,r.kt)("li",{parentName:"ul"},"b) El patr\xf3n Prototype se utiliza para crear una \xfanica instancia de una clase, mientras que el patr\xf3n Singleton se utiliza para crear m\xfaltiples instancias de una clase."),(0,r.kt)("li",{parentName:"ul"},"c) No hay diferencia entre ambos patrones."),(0,r.kt)("li",{parentName:"ul"},"Respuesta: a)")),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfQu\xe9 tipos de objetos se benefician m\xe1s del uso del patr\xf3n Prototype?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Objetos que son costosos o dif\xedciles de crear."),(0,r.kt)("li",{parentName:"ul"},"b) Objetos que no tienen una estructura fija."),(0,r.kt)("li",{parentName:"ul"},"c) Objetos que son simples y no necesitan mucha personalizaci\xf3n."),(0,r.kt)("li",{parentName:"ul"},"Respuesta: a)")),(0,r.kt)("h3",{id:"singleton"},"Singleton"),(0,r.kt)("p",null,"El Singleton garantiza que una clase solo tenga una instancia, y proporciona un punto de acceso global a ella. La clase Singleton contiene una instancia privada de s\xed misma y un constructor privado para evitar que se cree m\xe1s de una instancia. En su lugar, proporciona un m\xe9todo est\xe1tico para obtener la \xfanica instancia disponible."),(0,r.kt)("p",null,"Una de las ventajas del patr\xf3n Singleton es que garantiza que solo haya una instancia de la clase, lo que puede mejorar el rendimiento y reducir la sobrecarga de memoria. Sin embargo, tambi\xe9n puede ser una desventaja, ya que puede ser dif\xedcil probar el c\xf3digo que utiliza el Singleton y puede dificultar la extensibilidad del c\xf3digo."),(0,r.kt)("p",null,"En general, el patr\xf3n Singleton es \xfatil cuando se necesita una instancia global de una clase que sea f\xe1cilmente accesible en todo el programa y solo necesite ser creada una vez. Sin embargo, tambi\xe9n es importante tener en cuenta las posibles desventajas del patr\xf3n y considerar cuidadosamente si es el enfoque adecuado para el problema que se est\xe1 resolviendo."),(0,r.kt)("h4",{id:"ejemplo-de-desarrollo-singleton"},"Ejemplo de desarrollo Singleton"),(0,r.kt)("p",null,"En este ejemplo, la clase DatabaseConnection implementa el patr\xf3n Singleton para garantizar que solo haya una instancia de la conexi\xf3n a la base de datos en todo el programa. La clase tiene un constructor privado que solo puede ser llamado internamente y un m\xe9todo est\xe1tico getInstance que devuelve la \xfanica instancia de la clase. Si la instancia a\xfan no ha sido creada, se crea una nueva instancia y se devuelve la conexi\xf3n PDO."),(0,r.kt)("p",null,"Tambi\xe9n se han agregado los m\xe9todos ",(0,r.kt)("strong",{parentName:"p"},"clone y "),"wakeup para evitar la creaci\xf3n de copias o deserializaci\xf3n de la instancia existente."),(0,r.kt)("p",null,"Para utilizar esta conexi\xf3n a la base de datos, simplemente se llama al m\xe9todo getInstance con los par\xe1metros necesarios para crear la conexi\xf3n, como se muestra a continuaci\xf3n:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-php"},"$pdo = DatabaseConnection::getInstance('mysql:host=localhost;dbname=mydatabase', 'username', 'password');\n")),(0,r.kt)("p",null,"De esta forma, siempre se obtiene la misma instancia de la conexi\xf3n a la base de datos, lo que ayuda a evitar problemas de concurrencia y mejora la eficiencia del programa."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class DatabaseConnection\n{\n    private static $instance;\n    private $pdo;\n\n    private function __construct($dsn, $username, $password)\n    {\n        $this->pdo = new PDO($dsn, $username, $password);\n    }\n\n    public static function getInstance($dsn, $username, $password)\n    {\n        if (!isset(self::$instance)) {\n            self::$instance = new self($dsn, $username, $password);\n        }\n        return self::$instance->pdo;\n    }\n\n    public function __clone()\n    {\n        trigger_error('Clone is not allowed.', E_USER_ERROR);\n    }\n\n    public function __wakeup()\n    {\n        trigger_error('Deserializing is not allowed.', E_USER_ERROR);\n    }\n}\n")),(0,r.kt)("h4",{id:"desventajas-de-singleton"},"Desventajas de Singleton"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Puede ser dif\xedcil de probar: Al usar Singleton en una aplicaci\xf3n, puede ser dif\xedcil escribir pruebas unitarias para su c\xf3digo, ya que el estado de Singleton se comparte en toda la aplicaci\xf3n. Esto puede dificultar la reproducibilidad de errores y aumentar la complejidad de las pruebas.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Acoplamiento: El patr\xf3n Singleton puede aumentar el acoplamiento entre clases, ya que cada clase que utiliza Singleton debe conocer su existencia y utilizarla expl\xedcitamente.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Dependencia del orden de inicializaci\xf3n: Si las clases dependen del Singleton, su orden de inicializaci\xf3n es importante. Si se inicializa en el orden incorrecto, esto puede provocar errores en la aplicaci\xf3n.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Problemas de concurrencia: El patr\xf3n Singleton puede tener problemas de concurrencia, especialmente en aplicaciones que se ejecutan en paralelo o en sistemas distribuidos. Si varios subprocesos acceden al Singleton al mismo tiempo, puede provocar errores y comportamientos inesperados.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Problemas de escalabilidad: El patr\xf3n Singleton puede hacer que sea dif\xedcil escalar una aplicaci\xf3n, ya que la aplicaci\xf3n est\xe1 dise\xf1ada para depender de una sola instancia de una clase. Si se necesita escalar una aplicaci\xf3n para manejar m\xe1s tr\xe1fico o usuarios, es posible que el patr\xf3n Singleton no sea la mejor opci\xf3n."))),(0,r.kt)("h3",{id:"test-de-conocimientos-generales"},"Test de conocimientos generales"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l de los siguientes patrones de dise\xf1o creacionales proporciona una interfaz para crear objetos en una superclase, pero permite a las subclases alterar el tipo de objetos que se crear\xe1n?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Singleton"),(0,r.kt)("li",{parentName:"ul"},"b) Builder"),(0,r.kt)("li",{parentName:"ul"},"c) Abstract Factory"),(0,r.kt)("li",{parentName:"ul"},"d) Prototype"),(0,r.kt)("li",{parentName:"ul"},"Respuesta: c) Abstract Factory")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l de los siguientes patrones de dise\xf1o creacionales se utiliza para garantizar que solo haya una instancia de una clase y proporcionar un punto de acceso global a ella?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Prototype"),(0,r.kt)("li",{parentName:"ul"},"b) Singleton"),(0,r.kt)("li",{parentName:"ul"},"c) Factory Method"),(0,r.kt)("li",{parentName:"ul"},"d) Builder"),(0,r.kt)("li",{parentName:"ul"},"Respuesta: b) Singleton")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l de los siguientes patrones de dise\xf1o creacionales se utiliza para crear objetos complejos paso a paso y permitir su construcci\xf3n en diferentes etapas?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Prototype"),(0,r.kt)("li",{parentName:"ul"},"b) Abstract Factory"),(0,r.kt)("li",{parentName:"ul"},"c) Builder"),(0,r.kt)("li",{parentName:"ul"},"d) Factory Method"),(0,r.kt)("li",{parentName:"ul"},"Respuesta: c) Builder")),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l de los siguientes patrones de dise\xf1o creacionales se utiliza para crear objetos sin tener que especificar la clase exacta del objeto que se crear\xe1?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Abstract Factory"),(0,r.kt)("li",{parentName:"ul"},"b) Builder"),(0,r.kt)("li",{parentName:"ul"},"c) Prototype"),(0,r.kt)("li",{parentName:"ul"},"d) Factory Method"),(0,r.kt)("li",{parentName:"ul"},"Respuesta: c) Prototype")),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l de los siguientes patrones de dise\xf1o creacionales se utiliza para definir una interfaz para crear objetos, pero deja que las subclases decidan qu\xe9 clase instanciar?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Prototype"),(0,r.kt)("li",{parentName:"ul"},"b) Singleton"),(0,r.kt)("li",{parentName:"ul"},"c) Abstract Factory"),(0,r.kt)("li",{parentName:"ul"},"d) Factory Method"),(0,r.kt)("li",{parentName:"ul"},"Respuesta: d) Factory Method")),(0,r.kt)("ol",{start:6},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l de los siguientes patrones de dise\xf1o creacionales se utiliza para crear objetos de una sola vez y mantener una \xfanica instancia en toda la aplicaci\xf3n?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Abstract Factory"),(0,r.kt)("li",{parentName:"ul"},"b) Singleton"),(0,r.kt)("li",{parentName:"ul"},"c) Builder"),(0,r.kt)("li",{parentName:"ul"},"d) Prototype"),(0,r.kt)("li",{parentName:"ul"},"Respuesta: b) Singleton")),(0,r.kt)("ol",{start:7},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l de los siguientes patrones de dise\xf1o creacionales se utiliza para crear una jerarqu\xeda de f\xe1bricas relacionadas o dependientes sin especificar sus clases concretas?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Factory Method"),(0,r.kt)("li",{parentName:"ul"},"b) Singleton"),(0,r.kt)("li",{parentName:"ul"},"c) Abstract Factory"),(0,r.kt)("li",{parentName:"ul"},"d) Builder"),(0,r.kt)("li",{parentName:"ul"},"Respuesta: c) Abstract Factory")),(0,r.kt)("ol",{start:8},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l de los siguientes patrones de dise\xf1o creacionales se utiliza para encapsular la creaci\xf3n de objetos y ocultar la l\xf3gica de creaci\xf3n detr\xe1s de una interfaz com\xfan?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Builder"),(0,r.kt)("li",{parentName:"ul"},"b) Prototype"),(0,r.kt)("li",{parentName:"ul"},"c) Abstract Factory"),(0,r.kt)("li",{parentName:"ul"},"d) Factory Method"),(0,r.kt)("li",{parentName:"ul"},"Respuesta: d) Factory Method")),(0,r.kt)("ol",{start:9},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l de los siguientes patrones de dise\xf1o creacionales se utiliza para crear objetos complejos utilizando una serie de pasos bien definidos y concretos?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Abstract Factory"),(0,r.kt)("li",{parentName:"ul"},"b) Singleton"),(0,r.kt)("li",{parentName:"ul"},"c) Builder"),(0,r.kt)("li",{parentName:"ul"},"d) Prototype"),(0,r.kt)("li",{parentName:"ul"},"Respuesta: c) Builder")),(0,r.kt)("ol",{start:10},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l de los siguientes patrones de dise\xf1o creacionales se utiliza para crear objetos basados en una jerarqu\xeda de clases y permitir que una subclase cambie el tipo de objeto que se crea?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Factory Method"),(0,r.kt)("li",{parentName:"ul"},"b) Singleton"),(0,r.kt)("li",{parentName:"ul"},"c) Abstract Factory"),(0,r.kt)("li",{parentName:"ul"},"d) Builder"),(0,r.kt)("li",{parentName:"ul"},"Respuesta: a) Factory Method")))}d.isMDXComponent=!0}}]);