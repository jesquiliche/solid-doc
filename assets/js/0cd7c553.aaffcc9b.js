"use strict";(self.webpackChunksolid=self.webpackChunksolid||[]).push([[528],{3905:(e,a,n)=>{n.d(a,{Zo:()=>d,kt:()=>b});var t=n(7294);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function o(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function i(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?o(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function l(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},o=Object.keys(e);for(t=0;t<o.length;t++)n=o[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)n=o[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=t.createContext({}),p=function(e){var a=t.useContext(s),n=a;return e&&(n="function"==typeof e?e(a):i(i({},a),e)),n},d=function(e){var a=p(e.components);return t.createElement(s.Provider,{value:a},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},m=t.forwardRef((function(e,a){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(n),m=r,b=c["".concat(s,".").concat(m)]||c[m]||u[m]||o;return n?t.createElement(b,i(i({ref:a},d),{},{components:n})):t.createElement(b,i({ref:a},d))}));function b(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in a)hasOwnProperty.call(a,s)&&(l[s]=a[s]);l.originalType=e,l[c]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return t.createElement.apply(null,i)}return t.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6645:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var t=n(7462),r=(n(7294),n(3905));const o={sidebar_position:3},i="Patrones de dise\xf1o estructurales",l={unversionedId:"tutorial-extras/Estructurales",id:"tutorial-extras/Estructurales",title:"Patrones de dise\xf1o estructurales",description:"\xbfQu\xe9 son los patrones de dise\xf1o creacionales?",source:"@site/docs/tutorial-extras/03-Estructurales.md",sourceDirName:"tutorial-extras",slug:"/tutorial-extras/Estructurales",permalink:"/solid-doc/docs/tutorial-extras/Estructurales",draft:!1,editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/tutorial-extras/03-Estructurales.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Patrones de dise\xf1o creacionales",permalink:"/solid-doc/docs/tutorial-extras/Creacionales"}},s={},p=[{value:"\xbfQu\xe9 son los patrones de dise\xf1o creacionales?",id:"qu\xe9-son-los-patrones-de-dise\xf1o-creacionales",level:2},{value:"Tipos de patrones estructurales",id:"tipos-de-patrones-estructurales",level:2},{value:"Adapter",id:"adapter",level:3},{value:"Ejemplo de Adapter",id:"ejemplo-de-adapter",level:4},{value:"Desventajas de Adapter",id:"desventajas-de-adapter",level:4},{value:"Test de repaso",id:"test-de-repaso",level:4},{value:"Bridge",id:"bridge",level:3},{value:"Ejemplo de desarrollo Bridge",id:"ejemplo-de-desarrollo-bridge",level:4},{value:"Desventajas del patr\xf3n Bridge",id:"desventajas-del-patr\xf3n-bridge",level:4},{value:"Test",id:"test",level:4},{value:"Composite",id:"composite",level:3},{value:"Ejemplo de desarrollo",id:"ejemplo-de-desarrollo",level:4},{value:"Decorator",id:"decorator",level:3},{value:"Desventajas de Decorator",id:"desventajas-de-decorator",level:4},{value:"Ejemplo de desarrollo Decorator",id:"ejemplo-de-desarrollo-decorator",level:4}],d={toc:p},c="wrapper";function u(e){let{components:a,...n}=e;return(0,r.kt)(c,(0,t.Z)({},d,n,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"patrones-de-dise\xf1o-estructurales"},"Patrones de dise\xf1o estructurales"),(0,r.kt)("h2",{id:"qu\xe9-son-los-patrones-de-dise\xf1o-creacionales"},"\xbfQu\xe9 son los patrones de dise\xf1o creacionales?"),(0,r.kt)("p",null,"Los patrones de dise\xf1o estructurales son aquellos que se centran en c\xf3mo se organizan y estructuran las clases y objetos en un sistema. Estos patrones se utilizan para lograr una mayor flexibilidad y escalabilidad del sistema, al mismo tiempo que se reduce la complejidad y se mejora la eficiencia."),(0,r.kt)("p",null,"Los patrones estructurales incluyen patrones como el adaptador, el puente, el composite, el decorador, la fachada y el proxy. Cada uno de estos patrones se centra en un aspecto particular de la estructura del sistema y ofrece una soluci\xf3n com\xfan a un problema com\xfan que se encuentra en muchos sistemas."),(0,r.kt)("p",null,"Por ejemplo, el patr\xf3n adaptador se utiliza para permitir que dos clases incompatibles trabajen juntas. El patr\xf3n puente se utiliza para separar una abstracci\xf3n de su implementaci\xf3n, lo que permite que ambos cambien independientemente sin afectar al otro. El patr\xf3n composite se utiliza para tratar a un grupo de objetos como si fueran un solo objeto, lo que permite tratar a los objetos individuales y al grupo de objetos de la misma manera. El patr\xf3n decorador se utiliza para agregar funcionalidad a un objeto existente sin cambiar su estructura, mientras que el patr\xf3n fachada se utiliza para proporcionar una interfaz simple para un sistema complejo. Finalmente, el patr\xf3n proxy se utiliza para proporcionar un sustituto o marcador de posici\xf3n para otro objeto, lo que permite controlar el acceso al objeto real."),(0,r.kt)("h2",{id:"tipos-de-patrones-estructurales"},"Tipos de patrones estructurales"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Tipo de patr\xf3n estructural"),(0,r.kt)("th",{parentName:"tr",align:null},"Descripci\xf3n breve"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Adapter"),(0,r.kt)("td",{parentName:"tr",align:null},"Convierte la interfaz de una clase en otra interfaz que se espera.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Bridge"),(0,r.kt)("td",{parentName:"tr",align:null},"Separa una abstracci\xf3n de su implementaci\xf3n para que puedan variar independientemente.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Composite"),(0,r.kt)("td",{parentName:"tr",align:null},"Agrupa objetos en una estructura de \xe1rbol para representar jerarqu\xedas parte-todo.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Decorator"),(0,r.kt)("td",{parentName:"tr",align:null},"A\xf1ade responsabilidades adicionales a un objeto de manera din\xe1mica.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Facade"),(0,r.kt)("td",{parentName:"tr",align:null},"Proporciona una interfaz unificada para un conjunto de interfaces en un subsistema.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Flyweight"),(0,r.kt)("td",{parentName:"tr",align:null},"Divide los objetos en objetos compartidos y no compartidos para reducir la memoria utilizada.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Proxy"),(0,r.kt)("td",{parentName:"tr",align:null},"Proporciona un representante o sustituto de otro objeto para controlar el acceso a \xe9ste.")))),(0,r.kt)("h3",{id:"adapter"},"Adapter"),(0,r.kt)("p",null,"El patr\xf3n ",(0,r.kt)("strong",{parentName:"p"},"Adapter")," es un patr\xf3n estructural que permite que objetos con interfaces incompatibles trabajen juntos. Convierte la interfaz de una clase en otra interfaz que el cliente espera."),(0,r.kt)("p",null,"El patr\xf3n ",(0,r.kt)("strong",{parentName:"p"},"Adapter")," se puede clasificar en dos tipos: el Adapter de clase y el Adapter de objeto. El Adapter de clase utiliza la herencia para adaptar una interfaz existente, mientras que el Adapter de objeto utiliza la composici\xf3n para adaptar una interfaz existente."),(0,r.kt)("p",null,"El objetivo del patr\xf3n Adapter es proporcionar una capa intermedia entre dos interfaces incompatibles para permitir su interacci\xf3n. Esto se logra mediante la creaci\xf3n de un objeto adaptador que convierte la interfaz original en la interfaz esperada por el cliente."),(0,r.kt)("p",null,"Ejemplos de este patr\xf3n se pueden encontrar en el uso de adaptadores de enchufe, donde se utilizan para permitir que dispositivos con diferentes enchufes se conecten a una toma de corriente com\xfan. Tambi\xe9n se puede utilizar en el software, por ejemplo, para convertir los datos de una fuente de datos en un formato que pueda ser utilizado por una aplicaci\xf3n."),(0,r.kt)("p",null,"En este ejemplo, la interfaz ",(0,r.kt)("strong",{parentName:"p"},"Product")," define la operaci\xf3n que todos los productos deben implementar. ConcreteProduct1 y ConcreteProduct2 son implementaciones concretas de ",(0,r.kt)("strong",{parentName:"p"},"Product"),". La clase abstracta ",(0,r.kt)("strong",{parentName:"p"},"Creator")," define el m\xe9todo factoryMethod que las subclases deben implementar para crear los objetos. ",(0,r.kt)("strong",{parentName:"p"},"ConcreteCreator1")," y ",(0,r.kt)("strong",{parentName:"p"},"ConcreteCreator2")," son las implementaciones concretas de Creator que devuelven instancias concretas de ",(0,r.kt)("strong",{parentName:"p"},"ConcreteProduct1")," y ",(0,r.kt)("strong",{parentName:"p"},"ConcreteProduct2"),", respectivamente. La funci\xf3n clientCode demuestra c\xf3mo se pueden utilizar las clases anteriores para crear diferentes tipos de objetos."),(0,r.kt)("h4",{id:"ejemplo-de-adapter"},"Ejemplo de Adapter"),(0,r.kt)("p",null,"Supongamos que tenemos una clase PaymentProcessor que procesa pagos utilizando la API de un proveedor de pagos espec\xedfico. Pero ahora queremos cambiar a un nuevo proveedor de pagos que tiene una API diferente. En lugar de cambiar la l\xf3gica de PaymentProcessor, podemos crear un adaptador para la nueva API y utilizarlo para procesar pagos. Este adaptador actuar\xe1 como un intermediario entre el PaymentProcessor y la nueva API."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'interface PaymentProvider {\n    public function pay($amount);\n}\n\nclass OldPaymentProvider implements PaymentProvider {\n    public function pay($amount) {\n        echo "Pagando $amount usando la API de OldPaymentProvider\\n";\n    }\n}\n\nclass NewPaymentProvider {\n    public function charge($amount) {\n        echo "Cobrando $amount usando la API de NewPaymentProvider\\n";\n    }\n}\n\nclass NewPaymentProviderAdapter implements PaymentProvider {\n    private $provider;\n\n    public function __construct(NewPaymentProvider $provider) {\n        $this->provider = $provider;\n    }\n\n    public function pay($amount) {\n        $this->provider->charge($amount);\n    }\n}\n\nclass PaymentProcessor {\n    private $provider;\n\n    public function __construct(PaymentProvider $provider) {\n        $this->provider = $provider;\n    }\n\n    public function processPayment($amount) {\n        $this->provider->pay($amount);\n    }\n}\n\n// Usando el viejo proveedor de pagos\n$paymentProcessor = new PaymentProcessor(new OldPaymentProvider());\n$paymentProcessor->processPayment(100);\n\n// Cambiando al nuevo proveedor de pagos con un adaptador\n$newPaymentProvider = new NewPaymentProvider();\n$paymentProcessor = new PaymentProcessor(new NewPaymentProviderAdapter($newPaymentProvider));\n$paymentProcessor->processPayment(200);\n\n')),(0,r.kt)("p",null,"En este ejemplo, ",(0,r.kt)("strong",{parentName:"p"},"OldPaymentProvider")," y ",(0,r.kt)("strong",{parentName:"p"},"NewPaymentProvider")," son dos proveedores de pagos diferentes con APIs diferentes. ",(0,r.kt)("strong",{parentName:"p"},"PaymentProcessor")," es la clase que utiliza la API del proveedor de pagos para procesar pagos. En lugar de cambiar la implementaci\xf3n de ",(0,r.kt)("strong",{parentName:"p"},"PaymentProcessor")," cuando cambiamos al nuevo proveedor de pagos, creamos un adaptador ",(0,r.kt)("strong",{parentName:"p"},"NewPaymentProviderAdapter")," que se encarga de adaptar la API del nuevo proveedor de pagos a la interfaz del PaymentProvider. De esta manera, podemos seguir utilizando la misma implementaci\xf3n de PaymentProcessor sin necesidad de cambiar nada en \xe9l."),(0,r.kt)("h4",{id:"desventajas-de-adapter"},"Desventajas de Adapter"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Complejidad: La implementaci\xf3n del patr\xf3n Adapter puede ser compleja, ya que implica la creaci\xf3n de una interfaz com\xfan para hacer que los objetos sean compatibles entre s\xed.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Overhead: El patr\xf3n Adapter agrega una capa adicional de indirecci\xf3n, lo que puede aumentar el overhead y disminuir el rendimiento.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Aumento de la complejidad del c\xf3digo: El uso excesivo de adaptadores puede aumentar la complejidad del c\xf3digo y hacerlo m\xe1s dif\xedcil de mantener y entender.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Requiere una buena planificaci\xf3n: Es importante planificar cuidadosamente c\xf3mo se va a implementar el patr\xf3n Adapter para evitar problemas en el futuro.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Dificultad para mantener la compatibilidad: A medida que evolucionan los sistemas, puede ser dif\xedcil mantener la compatibilidad entre los diferentes objetos que se est\xe1n adaptando."))),(0,r.kt)("h4",{id:"test-de-repaso"},"Test de repaso"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l es el prop\xf3sito del patr\xf3n Adapter?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Permitir que los objetos trabajen juntos sin modificar su interfaz."),(0,r.kt)("li",{parentName:"ul"},"b) Permitir que los objetos trabajen juntos modificando su interfaz."),(0,r.kt)("li",{parentName:"ul"},"c) Permitir que los objetos trabajen individualmente sin interferir en la interfaz de otros objetos."),(0,r.kt)("li",{parentName:"ul"},"Respuesta: a) Permitir que los objetos trabajen juntos sin modificar su interfaz.")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1les son las dos formas principales de implementar el patr\xf3n Adapter?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Clases y objetos."),(0,r.kt)("li",{parentName:"ul"},"b) Herencia y composici\xf3n."),(0,r.kt)("li",{parentName:"ul"},"c) Interfaces y clases abstractas."),(0,r.kt)("li",{parentName:"ul"},"Respuesta: b) Herencia y composici\xf3n.")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},'\xbfQu\xe9 es un "Adapter de objeto"?')))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Una clase que adapta una interfaz de objeto existente a otra interfaz requerida por el cliente."),(0,r.kt)("li",{parentName:"ul"},"b) Un objeto que se utiliza para conectar una aplicaci\xf3n con una base de datos."),(0,r.kt)("li",{parentName:"ul"},"c) Una interfaz que define una serie de m\xe9todos para que los objetos los implementen."),(0,r.kt)("li",{parentName:"ul"},"Respuesta: a) Una clase que adapta una interfaz de objeto existente a otra interfaz requerida por el cliente.")),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfEn qu\xe9 se diferencia el patr\xf3n Adapter del patr\xf3n Bridge?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) El patr\xf3n Adapter se utiliza para adaptar una interfaz existente, mientras que el patr\xf3n Bridge se utiliza para separar la interfaz de una abstracci\xf3n de su implementaci\xf3n."),(0,r.kt)("li",{parentName:"ul"},"b) El patr\xf3n Adapter se utiliza para conectar dos interfaces incompatibles, mientras que el patr\xf3n Bridge se utiliza para conectar dos sistemas diferentes."),(0,r.kt)("li",{parentName:"ul"},"c) El patr\xf3n Adapter se utiliza en sistemas distribuidos, mientras que el patr\xf3n Bridge se utiliza en sistemas centralizados."),(0,r.kt)("li",{parentName:"ul"},"Respuesta: a) El patr\xf3n Adapter se utiliza para adaptar una interfaz existente, mientras que el patr\xf3n Bridge se utiliza para separar la interfaz de una abstracci\xf3n de su implementaci\xf3n.")),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfEn qu\xe9 situaciones es \xfatil utilizar el patr\xf3n Adapter?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Cuando se necesita adaptar una interfaz existente a una nueva interfaz requerida por el cliente."),(0,r.kt)("li",{parentName:"ul"},"b) Cuando se necesita crear una interfaz abstracta para separar una abstracci\xf3n de su implementaci\xf3n."),(0,r.kt)("li",{parentName:"ul"},"c) Cuando se necesita controlar el acceso a un objeto y su comportamiento."),(0,r.kt)("li",{parentName:"ul"},"Respuesta: a) Cuando se necesita adaptar una interfaz existente a una nueva interfaz requerida por el cliente.")),(0,r.kt)("h3",{id:"bridge"},"Bridge"),(0,r.kt)("p",null,"En el contexto de dise\xf1o de patrones, el patr\xf3n Bridge (puente) es un patr\xf3n estructural que permite desacoplar una abstracci\xf3n de su implementaci\xf3n, de modo que ambas puedan variar independientemente sin afectar a la otra."),(0,r.kt)("p",null,"La idea b\xe1sica detr\xe1s del patr\xf3n Bridge es dividir una abstracci\xf3n (una clase) y su implementaci\xf3n (otra clase) en dos jerarqu\xedas independientes. De esta forma, ambas jerarqu\xedas pueden variar por separado y se pueden combinar en tiempo de ejecuci\xf3n para crear diferentes objetos con diferentes implementaciones."),(0,r.kt)("p",null,'El patr\xf3n Bridge se utiliza com\xfanmente en situaciones en las que se desea separar la interfaz de usuario de la l\xf3gica de negocio subyacente. Por ejemplo, supongamos que estamos desarrollando una aplicaci\xf3n de dibujo en la que se pueden crear diferentes tipos de formas, como c\xedrculos, rect\xe1ngulos y tri\xe1ngulos. En lugar de tener una clase "Forma" monol\xedtica que contenga toda la l\xf3gica para cada tipo de forma, podr\xedamos utilizar el patr\xf3n Bridge para separar la abstracci\xf3n de "Forma" de su implementaci\xf3n. De esta forma, podr\xedamos tener una jerarqu\xeda de clases "Forma" y una jerarqu\xeda de clases "Implementaci\xf3n de dibujo" separadas, y combinarlas en tiempo de ejecuci\xf3n para crear diferentes formas con diferentes estilos de dibujo.'),(0,r.kt)("p",null,"En resumen, el patr\xf3n Bridge es una t\xe9cnica \xfatil para desacoplar una abstracci\xf3n de su implementaci\xf3n, lo que puede mejorar la flexibilidad, la modularidad y la reutilizaci\xf3n del c\xf3digo."),(0,r.kt)("h4",{id:"ejemplo-de-desarrollo-bridge"},"Ejemplo de desarrollo Bridge"),(0,r.kt)("p",null,"Aqu\xed te muestro un ejemplo sencillo de c\xf3mo se podr\xeda implementar el patr\xf3n Bridge en PHP para crear diferentes tipos de motores de combusti\xf3n:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'<?php\ninterface Motor {\n    public function encender();\n}\n\nclass MotorGasolina implements Motor {\n    public function encender() {\n        echo "Encendiendo motor de gasolina...\\n";\n    }\n}\n\nclass MotorDiesel implements Motor {\n    public function encender() {\n        echo "Encendiendo motor diesel...\\n";\n    }\n}\n\nabstract class Vehiculo {\n    protected $motor;\n    \n    public function __construct(Motor $motor) {\n        $this->motor = $motor;\n    }\n    \n    abstract public function conducir();\n}\n\nclass Coche extends Vehiculo {\n    public function conducir() {\n        $this->motor->encender();\n        echo "Conduciendo coche...\\n";\n    }\n}\n\nclass Camion extends Vehiculo {\n    public function conducir() {\n        $this->motor->encender();\n        echo "Conduciendo camion...\\n";\n    }\n}\n\n// Crear un motor de gasolina\n$motorGasolina = new MotorGasolina();\n\n// Crear un coche con un motor de gasolina\n$coche = new Coche($motorGasolina);\n$coche->conducir(); // Output: Encendiendo motor de gasolina... Conduciendo coche...\n\n// Crear un motor diesel\n$motorDiesel = new MotorDiesel();\n\n// Crear un camion con un motor diesel\n$camion = new Camion($motorDiesel);\n$camion->conducir(); // Output: Encendiendo motor diesel... Conduciendo camion...\n?>\n')),(0,r.kt)("p",null,"En este ejemplo, tenemos una interfaz ",(0,r.kt)("strong",{parentName:"p"},"Motor")," que define el m\xe9todo ",(0,r.kt)("strong",{parentName:"p"},"encender()"),", y dos clases que implementan esta interfaz: ",(0,r.kt)("strong",{parentName:"p"},"MotorGasolina")," y ",(0,r.kt)("strong",{parentName:"p"},"MotorDiesel"),". Luego, tenemos una clase abstracta Vehiculo que tiene un objeto ",(0,r.kt)("strong",{parentName:"p"},"Motor")," y un m\xe9todo abstracto ",(0,r.kt)("strong",{parentName:"p"},"conducir()"),". Finalmente, tenemos dos clases que extienden la clase Vehiculo ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"(un Coche y un Camion)"))," que implementan el m\xe9todo ",(0,r.kt)("strong",{parentName:"p"},"conducir()"),"."),(0,r.kt)("p",null,"Al crear un objeto ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Coche o Camion")),", debemos pasarle un objeto ",(0,r.kt)("strong",{parentName:"p"},"Motor"),", que determinar\xe1 el tipo de motor que tiene el veh\xedculo. Cuando llamamos al m\xe9todo ",(0,r.kt)("strong",{parentName:"p"},"conducir()"),", el veh\xedculo enciende su motor y comienza a conducir."),(0,r.kt)("h4",{id:"desventajas-del-patr\xf3n-bridge"},"Desventajas del patr\xf3n Bridge"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Complejidad adicional: la implementaci\xf3n del patr\xf3n Bridge puede requerir m\xe1s clases y estructuras adicionales, lo que puede aumentar la complejidad general del c\xf3digo.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Coste de mantenimiento: si se hacen cambios en las clases base o en las implementaciones del puente, puede ser necesario realizar cambios en varias partes del c\xf3digo, lo que puede aumentar el coste y el tiempo de mantenimiento.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Sobrecarga de la abstracci\xf3n: si la abstracci\xf3n tiene demasiadas responsabilidades o m\xe9todos adicionales, puede ser dif\xedcil de manejar y puede tener un rendimiento deficiente.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Necesidad de interfaces claras: para que el patr\xf3n Bridge funcione de manera efectiva, es necesario tener interfaces claras y bien definidas entre la abstracci\xf3n y las implementaciones del puente. Si las interfaces no est\xe1n bien definidas, pueden surgir problemas de compatibilidad y coherencia en el c\xf3digo."))),(0,r.kt)("p",null,"En general, el patr\xf3n Bridge es \xfatil para separar la abstracci\xf3n de su implementaci\xf3n y proporcionar una mayor flexibilidad y escalabilidad en el dise\xf1o del software, pero tambi\xe9n puede tener algunas desventajas y requiere un cuidadoso an\xe1lisis y dise\xf1o para ser implementado correctamente."),(0,r.kt)("h4",{id:"test"},"Test"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfQu\xe9 patr\xf3n de dise\xf1o se utiliza para separar la abstracci\xf3n de su implementaci\xf3n?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Bridge"),(0,r.kt)("li",{parentName:"ul"},"b) Adapter"),(0,r.kt)("li",{parentName:"ul"},"c) Singleton"),(0,r.kt)("li",{parentName:"ul"},"d) Prototype")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfQu\xe9 patr\xf3n de dise\xf1o se utiliza para permitir que la abstracci\xf3n y la implementaci\xf3n var\xeden de manera independiente?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Bridge"),(0,r.kt)("li",{parentName:"ul"},"b) Facade"),(0,r.kt)("li",{parentName:"ul"},"c) Decorator"),(0,r.kt)("li",{parentName:"ul"},"d) Observer")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfQu\xe9 es la abstracci\xf3n en el patr\xf3n Bridge?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) La interfaz que define la implementaci\xf3n espec\xedfica."),(0,r.kt)("li",{parentName:"ul"},"b) La clase que contiene la implementaci\xf3n concreta."),(0,r.kt)("li",{parentName:"ul"},"c) La clase que define la interfaz para la abstracci\xf3n."),(0,r.kt)("li",{parentName:"ul"},"d) La clase que contiene la l\xf3gica de negocio.")),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfQu\xe9 es la implementaci\xf3n en el patr\xf3n Bridge?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) La interfaz que define la implementaci\xf3n espec\xedfica."),(0,r.kt)("li",{parentName:"ul"},"b) La clase que contiene la implementaci\xf3n concreta."),(0,r.kt)("li",{parentName:"ul"},"c) La clase que define la interfaz para la abstracci\xf3n."),(0,r.kt)("li",{parentName:"ul"},"d) La clase que contiene la l\xf3gica de negocio.")),(0,r.kt)("ol",{start:5},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"\xbfCu\xe1l es uno de los beneficios del patr\xf3n Bridge?")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a) Mejora el rendimiento del sistema."),(0,r.kt)("li",{parentName:"ul"},"b) Permite que la abstracci\xf3n y la implementaci\xf3n var\xeden de manera independiente."),(0,r.kt)("li",{parentName:"ul"},"c) Proporciona una interfaz sencilla para interactuar con un conjunto complejo de subsistemas."),(0,r.kt)("li",{parentName:"ul"},"d) Reduce la complejidad del c\xf3digo.")),(0,r.kt)("p",null,"Respuestas:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"a"),(0,r.kt)("li",{parentName:"ol"},"a"),(0,r.kt)("li",{parentName:"ol"},"c"),(0,r.kt)("li",{parentName:"ol"},"b"),(0,r.kt)("li",{parentName:"ol"},"b")),(0,r.kt)("h3",{id:"composite"},"Composite"),(0,r.kt)("p",null,"El patr\xf3n ",(0,r.kt)("strong",{parentName:"p"},"Composite")," es un patr\xf3n de dise\xf1o estructural que se utiliza para componer objetos en estructuras de \xe1rbol para representar jerarqu\xedas de parte-todo."),(0,r.kt)("p",null,"El patr\xf3n ",(0,r.kt)("strong",{parentName:"p"},"Composite")," define una interfaz com\xfan para todos los objetos en la estructura y proporciona dos tipos de objetos: ",(0,r.kt)("strong",{parentName:"p"},"objetos hoja")," que no tienen hijos y objetos compuestos que tienen una ",(0,r.kt)("strong",{parentName:"p"},"lista de hijos"),". Esto permite que los clientes traten los objetos individuales y las composiciones de objetos de manera uniforme."),(0,r.kt)("p",null,"El patr\xf3n ",(0,r.kt)("strong",{parentName:"p"},"Composite")," se utiliza a menudo en interfaces gr\xe1ficas de usuario para representar estructuras de objetos complejas, como \xe1rboles de archivos y estructuras de men\xfas."),(0,r.kt)("p",null,"Algunas ventajas del patr\xf3n Composite son que permite trabajar con estructuras de \xe1rbol de manera uniforme, es decir, los clientes no tienen que preocuparse por distinguir entre objetos hoja y objetos compuestos. Adem\xe1s, el patr\xf3n Composite facilita la adici\xf3n de nuevos tipos de componentes a la estructura, ya que se pueden crear nuevos objetos hoja y objetos compuestos que implementen la interfaz com\xfan."),(0,r.kt)("p",null,"Sin embargo, el patr\xf3n Composite tambi\xe9n tiene algunas desventajas. Por ejemplo, puede ser dif\xedcil de implementar si los objetos hoja y los objetos compuestos tienen diferentes interfaces. Adem\xe1s, el patr\xf3n Composite puede afectar el rendimiento de una aplicaci\xf3n si la estructura de objetos es muy grande."),(0,r.kt)("h4",{id:"ejemplo-de-desarrollo"},"Ejemplo de desarrollo"),(0,r.kt)("p",null,"Supongamos que queremos crear una estructura de \xe1rbol de objetos que puedan ser representados y manejados de manera uniforme. Podr\xedamos definir una interfaz llamada Component que define la estructura base de cada objeto en el \xe1rbol, incluyendo la capacidad de agregar, eliminar y obtener hijos."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"interface Component {\n    public function add(Component $component);\n    public function remove(Component $component);\n    public function getChild(int $index): Component;\n    public function operation();\n}\n")),(0,r.kt)("p",null,"A continuaci\xf3n, podemos implementar la interfaz Component en una clase Leaf para representar los nodos hoja del \xe1rbol:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'class Leaf implements Component {\n    private $name;\n\n    public function __construct(string $name) {\n        $this->name = $name;\n    }\n\n    public function add(Component $component) {\n        // No se puede agregar a un nodo hoja\n    }\n\n    public function remove(Component $component) {\n        // No se puede eliminar de un nodo hoja\n    }\n\n    public function getChild(int $index): Component {\n        // No tiene hijos, no se puede obtener un hijo por \xedndice\n        return null;\n    }\n\n    public function operation() {\n        echo "Operaci\xf3n realizada en " . $this->name . "\\n";\n    }\n}\n')),(0,r.kt)("p",null,"Tambi\xe9n podemos implementar la interfaz Component en una clase Composite para representar los nodos internos del \xe1rbol que contienen otros nodos (hojas y/o nodos compuestos):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'class Composite implements Component {\n    private $name;\n    private $children = array();\n\n    public function __construct(string $name) {\n        $this->name = $name;\n    }\n\n    public function add(Component $component) {\n        array_push($this->children, $component);\n    }\n\n    public function remove(Component $component) {\n        $index = array_search($component, $this->children);\n        if ($index !== false) {\n            array_splice($this->children, $index, 1);\n        }\n    }\n\n    public function getChild(int $index): Component {\n        if (isset($this->children[$index])) {\n            return $this->children[$index];\n        } else {\n            return null;\n        }\n    }\n\n    public function operation() {\n        echo "Operaci\xf3n realizada en " . $this->name . "\\n";\n        foreach ($this->children as $child) {\n            $child->operation();\n        }\n    }\n}\n')),(0,r.kt)("p",null,"Finalmente, podemos crear una instancia de la clase ",(0,r.kt)("strong",{parentName:"p"},"Composite")," y agregar instancias de la clase ",(0,r.kt)("strong",{parentName:"p"},"Leaf")," y ",(0,r.kt)("strong",{parentName:"p"},"Composite")," como hijos:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'$root = new Composite("Ra\xedz");\n\n$node1 = new Leaf("Nodo 1");\n$node2 = new Composite("Nodo 2");\n\n$node21 = new Leaf("Nodo 2.1");\n$node22 = new Leaf("Nodo 2.2");\n\n$node2->add($node21);\n$node2->add($node22);\n\n$root->add($node1);\n$root->add($node2);\n\n$root->operation();\n')),(0,r.kt)("p",null,"En este ejemplo, el m\xe9todo operation() se llama en la instancia de Composite root, que a su vez llama al m\xe9todo operation() en cada uno de sus hijos. Como resultado, se ejecuta la operaci\xf3n en cada nodo del \xe1rbol."),(0,r.kt)("h3",{id:"decorator"},"Decorator"),(0,r.kt)("p",null,"El patr\xf3n Decorator es un patr\xf3n de dise\xf1o estructural que permite agregar funcionalidades adicionales a un objeto en tiempo de ejecuci\xf3n sin modificar su estructura b\xe1sica."),(0,r.kt)("p",null,"La idea principal del patr\xf3n es crear una clase Decorator que tenga el mismo tipo de interfaz que la clase original, y que tambi\xe9n contenga un objeto de la clase original. A continuaci\xf3n, se pueden agregar nuevos comportamientos al objeto original a trav\xe9s de los Decorator sin alterar la clase original."),(0,r.kt)("p",null,"Por ejemplo, si tenemos una clase Pizza que tiene un m\xe9todo para calcular su costo, podemos crear un Decorator Topping que tome una Pizza como argumento en su constructor, y que agregue un costo adicional por cada topping que se agregue a la pizza."),(0,r.kt)("h4",{id:"desventajas-de-decorator"},"Desventajas de Decorator"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Aumento de la complejidad: Al agregar varias capas de decoradores, el c\xf3digo puede volverse m\xe1s complejo y dif\xedcil de entender y mantener.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Posible impacto en el rendimiento: Agregar m\xfaltiples decoradores puede tener un impacto en el rendimiento del sistema, especialmente si los decoradores realizan operaciones costosas.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Problemas de interoperabilidad: A veces, el patr\xf3n Decorator puede dificultar la interoperabilidad con otros sistemas o bibliotecas de terceros que no usan el mismo patr\xf3n.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Sobrecarga de clases: El patr\xf3n Decorator puede requerir la creaci\xf3n de un gran n\xfamero de clases, lo que puede ser un desaf\xedo para la organizaci\xf3n y el mantenimiento del c\xf3digo.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Confusi\xf3n con otros patrones: El patr\xf3n Decorator puede confundirse con otros patrones, como el patr\xf3n Adapter o el patr\xf3n Composite, lo que puede llevar a malentendidos y errores de dise\xf1o."))),(0,r.kt)("h4",{id:"ejemplo-de-desarrollo-decorator"},"Ejemplo de desarrollo Decorator"),(0,r.kt)("p",null,"Supongamos que tenemos una clase sencilla llamada Text que representa un texto:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class Text\n{\n    private $text;\n\n    public function __construct(string $text)\n    {\n        $this->text = $text;\n    }\n\n    public function getText(): string\n    {\n        return $this->text;\n    }\n\n    public function setText(string $text)\n    {\n        $this->text = $text;\n    }\n}\n")),(0,r.kt)("p",null,"Ahora, queremos a\xf1adir algunas funcionalidades adicionales a esta clase sin modificarla directamente, utilizando el patr\xf3n ",(0,r.kt)("strong",{parentName:"p"},"Decorator"),". Para ello, creamos una interfaz ",(0,r.kt)("strong",{parentName:"p"},"TextDecorator")," que define la funci\xf3n ",(0,r.kt)("strong",{parentName:"p"},"decorate"),", que toma un objeto de tipo Text y devuelve otro objeto de tipo Text con las funcionalidades a\xf1adidas:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"interface TextDecorator\n{\n    public function decorate(Text $text): Text;\n}\n")),(0,r.kt)("p",null,"A continuaci\xf3n, creamos una clase BoldTextDecorator que implementa esta interfaz y a\xf1ade la funcionalidad de poner el texto en negrita:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class BoldTextDecorator implements TextDecorator\n{\n    public function decorate(Text $text): Text\n    {\n        $decoratedText = new Text('<b>' . $text->getText() . '</b>');\n        return $decoratedText;\n    }\n}\n")),(0,r.kt)("p",null,"Finalmente, creamos una clase ItalicTextDecorator que implementa la misma interfaz y a\xf1ade la funcionalidad de poner el texto en cursiva:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class ItalicTextDecorator implements TextDecorator\n{\n    public function decorate(Text $text): Text\n    {\n        $decoratedText = new Text('<i>' . $text->getText() . '</i>');\n        return $decoratedText;\n    }\n}\n")),(0,r.kt)("p",null,"Ahora podemos crear un objeto ",(0,r.kt)("strong",{parentName:"p"},"Text*")," y decorarlo con ambas funcionalidades:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"$text = new Text('Hello, world!');\n\n$boldTextDecorator = new BoldTextDecorator();\n$italicTextDecorator = new ItalicTextDecorator();\n\n$boldAndItalicText = $italicTextDecorator->decorate($boldTextDecorator->decorate($text));\necho $boldAndItalicText->getText(); // Output: <i><b>Hello, world!</b></i>\n")),(0,r.kt)("p",null,"En este ejemplo, hemos creado dos decoradores que a\xf1aden funcionalidades al objeto ",(0,r.kt)("strong",{parentName:"p"},"Text"),": uno que pone el texto en negrita y otro que lo pone en cursiva. Para decorar un objeto ",(0,r.kt)("strong",{parentName:"p"},"Text")," con ambas funcionalidades, simplemente aplicamos los decoradores en el orden deseado."))}u.isMDXComponent=!0}}]);